# Stringent v2 - Type Inference Fix Progress

## Task 1: Understanding the Codebase (COMPLETED)

### What is the `outputSchema` field on AST nodes? Where does it come from?

The `outputSchema` field is defined in `src/primitive/index.ts:31-34`:
```typescript
export interface ASTNode<TType extends string = string, TOutputSchema = unknown> {
  node: TType;
  outputSchema: TOutputSchema;
}
```

It represents the string type of the result (e.g., "number", "string", "boolean"). It comes from:
1. **Literal nodes**: Set by runtime parsers (e.g., `outputSchema: 'number'` for number literals)
2. **Identifier nodes**: Set from context data type (e.g., `ctx.data[name]`)
3. **Operator nodes**: Set from `nodeSchema.resultType` during `buildNodeResult()`

### How does `parser.parse()` preserve type information from input to output?

The parser uses a dual-track architecture:
1. **Compile-time**: The `Parse<TGrammar, TInput, Context>` type computes exact result types by tokenizing input and building typed AST nodes
2. **Runtime**: The runtime parser mirrors this structure, setting `outputSchema` fields correctly

The `createParser()` function casts runtime results to match compile-time types.

### What existing type utilities does the codebase have for mapping schema strings to TypeScript types?

In `src/schema/index.ts`:
- `SchemaToType<T>`: Maps "number" → number, "string" → string, etc.
- `InferNodeType<TSchema>`: Maps schema to AST node type
- `InferEvaluatedType<TSchema>`: Maps schema to runtime value type
- `InferBindings<TPattern>`: Extracts AST node types from pattern
- `InferEvaluatedBindings<TPattern>`: Extracts evaluated value types from pattern

### Why does the current `evaluate()` function lose type information?

The original function signature was:
```typescript
export function evaluate(ast: unknown, ctx: EvalContext): unknown
```

- Input type is `unknown` - TypeScript can't see the `outputSchema` field
- No type parameter captures the AST type
- Return type is hardcoded to `unknown`

## Task 2: Fix `evaluate()` Return Type (COMPLETED)

Fixed in `src/runtime/eval.ts`:
```typescript
type ExtractOutputSchema<T> = T extends { outputSchema: infer S extends string } ? S : 'unknown';

export function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>> {
  // Implementation unchanged, just casts to the inferred return type
}
```

Now when you call `evaluate()` with an AST that has `outputSchema: "number"`, the return type is `number`.

## Task 3: Fix `createEvaluator()` Return Type (COMPLETED)

Updated in `src/runtime/eval.ts`:
```typescript
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends Record<string, unknown>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>> {
    return evaluate(ast, { data, nodes });
  };
}
```

## Task 4: Add Type-Level Tests (COMPLETED)

Added comprehensive type-level tests in `src/runtime/eval.test.ts`:
- Type tests for `evaluate()` with all primitive types (number, string, boolean, null, undefined)
- Type tests for `evaluate()` with parsed expressions from `parser.parse()`
- Type tests for `evaluate()` with nested expressions
- Type tests for `createEvaluator()` helper
- Edge case tests for parentheses, ternary, and manually constructed ASTs

All 714 tests pass including 98 tests in eval.test.ts.

## Task 5: Update Documentation (COMPLETED)

Updated the documentation to reflect the new type-safe evaluation feature:

### README.md Updates
- Added "Type-Safe Evaluation" section with comprehensive examples
- Added code examples showing type inference for number, boolean, and string result types
- Updated the "Evaluate Expressions" section to highlight type inference
- Updated "Key Features" section to emphasize type-safe evaluation

### docs/api-reference.md Updates
- Updated `evaluate()` section with new generic signature:
  ```typescript
  function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>>
  ```
- Added documentation of the type utilities (`ExtractOutputSchema`, `SchemaToType`)
- Added detailed "Type Inference Example" showing how types flow through
- Updated `createEvaluator()` section with new generic signature
- Added type inference example for `createEvaluator()`

### Key Documentation Points
- Return type is inferred from AST's `outputSchema` field
- `outputSchema: "number"` → returns `number`
- `outputSchema: "string"` → returns `string`
- `outputSchema: "boolean"` → returns `boolean`
- `outputSchema: "null"` → returns `null`
- `outputSchema: "undefined"` → returns `undefined`
- Unknown schemas → returns `unknown`

---

## Summary

The core type inference fix is complete. The `evaluate()` and `createEvaluator()` functions now correctly infer return types from the AST's `outputSchema` field. This means:

```typescript
const ast = parser.parse('1 + 2', {});
const value = evaluate(ast[0], ctx);
// TypeScript now knows: typeof value === number
```

The implementation uses TypeScript's conditional types to extract the `outputSchema` from the AST type parameter and map it to the corresponding TypeScript type using `SchemaToType`.

## Task 6: Connect Parse Schema to Eval Data (COMPLETED)

Implemented type-safe data validation in `evaluate()` and `createEvaluator()`. The evaluator now requires that data passed to it matches the types expected by the AST's identifier nodes.

### Implementation

Added new type utilities in `src/runtime/eval.ts`:

```typescript
// Extract all identifier nodes from an AST recursively
type ExtractIdentifiers<T> = T extends { node: 'identifier'; name: infer N; outputSchema: infer S }
  ? { name: N; outputSchema: S }
  : T extends object
    ? { [K in keyof T]: ExtractIdentifiers<T[K]> }[keyof T]
    : never;

// Convert identifier tuples to required data object type
type IdentifiersToData<T> = T extends {
  name: infer N extends string;
  outputSchema: infer S extends string;
}
  ? { [K in N]: SchemaToType<S> }
  : never;

// Merge union of single-key objects into intersection
type UnionToIntersection<U> = ...

// Extract required data types from AST
export type ExtractRequiredData<T> =
  ExtractIdentifiers<T> extends never
    ? Record<string, never>  // No identifiers - empty data OK
    : UnionToIntersection<IdentifiersToData<ExtractIdentifiers<T>>>;
```

Updated function signatures:

```typescript
// evaluate() now requires data to match AST's identifiers
export function evaluate<T, TData extends ExtractRequiredData<T>>(
  ast: T,
  ctx: EvalContext<TData>
): SchemaToType<ExtractOutputSchema<T>>

// createEvaluator() also enforces data constraints
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends ExtractRequiredData<T>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>>
}
```

### Type Safety Features

1. **Missing variables cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x is required but not provided
   evaluate(ast, { data: {}, nodes });
   ```

2. **Wrong data types cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x should be number, not string
   evaluate(ast, { data: { x: 'wrong' }, nodes });
   ```

3. **Extra properties are allowed:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // OK - extra 'y' is fine
   evaluate(ast, { data: { x: 42, y: 'extra' }, nodes });
   ```

4. **Empty data for literal-only expressions:**
   ```typescript
   const ast = { node: 'literal', value: 42, outputSchema: 'number' } as const;
   // OK - no identifiers means no data required
   evaluate(ast, { data: {}, nodes });
   ```

### Tests Added

Added 21 new tests in `src/runtime/eval.test.ts` under "evaluate - data-schema connection (Task 6)":

**Type-level tests with manually constructed ASTs:**
- requires correct data types for identifiers
- rejects missing variables in data (type error)
- rejects wrong data types (type error)
- allows extra properties in data
- accepts empty data for expressions without identifiers
- infers correct data types for string identifiers
- infers correct data types for boolean identifiers
- handles multiple identifiers with different types
- handles nested expressions with identifiers

**Runtime tests with parsed expressions:**
- evaluates parsed expression with identifiers
- evaluates parsed identifier expression
- throws for missing variable at runtime
- evaluates parsed string identifier
- evaluates parsed boolean identifier
- evaluates parsed comparison with identifier
- evaluates parsed nested expression with identifiers

**createEvaluator type-level tests:**
- requires correct data types for identifiers (manual AST)
- rejects missing variables (type error)
- rejects wrong data types (type error)
- evaluates parsed expression (runtime)

### Limitations

The type-level data validation works best with manually constructed ASTs that use `as const`. When using `parser.parse()`, the parsed AST type uses generic `string` for identifier `outputSchema` instead of literal values like `'number'`. This is a pre-existing limitation in the parser's type inference that would require fixing the parse-time type flow (related to Tasks 1-5 arktype integration).

Runtime validation (throwing errors for missing/wrong types) still works correctly because the runtime preserves the actual schema values.

### Files Modified

- `src/runtime/eval.ts`: Added type utilities and updated function signatures
- `src/runtime/eval.test.ts`: Added 21 new tests, updated 1 existing test

All 734 tests pass. No new lint errors.

## Task 7 (PRD): Study ArkType Integration (COMPLETED)

This corresponds to PRD Task 1. Investigated how arktype can be used for compile-time and runtime type validation.

### Key Findings

**1. How does arktype's generic validation work?**
- `type('number')` creates a Type object that validates at runtime
- The Type object has an `.infer` property for extracting the TypeScript type
- Invalid type strings cause compile-time errors via TypeScript's type system

**2. How to validate type strings at compile time?**
- Use `type.validate<T>` in generic function parameters
- Example: `function fn<const T>(schema: type.validate<T>) { ... }`
- This causes compile errors for invalid type strings like 'garbage'

**3. How does type.infer work?**
- After creating a Type: `const t = type('number')`
- Extract the TS type: `type T = typeof t.infer` // number
- Works with all valid arktype definitions

**4. What arktype types should Stringent support initially?**
- All primitives: 'number', 'string', 'boolean', 'null', 'undefined'
- Unions: 'string | number' (for ternary result types)
- Subtypes: 'string.email', 'number.integer' (validated at runtime)
- Constraints: 'number >= 0' (validated at runtime)

### Integration Pattern for Stringent

For `lhs()`, `rhs()`, `expr()` constraint validation:
```typescript
export const lhs = <const T extends string>(constraint?: type.validate<T>) => ...
```

For `parser.parse()` schema validation:
```typescript
parse<TSchema extends Record<string, string>>(
  input: string,
  schema: { [K in keyof TSchema]: type.validate<TSchema[K]> }
) => ...
```

For `SchemaToType` replacement:
- Use arktype's `type.infer` mechanism
- Direct type creation preserves inference: `type NumType = typeof type('number').infer`
- Generic functions with `type.validate` may lose return type inference due to TS limitations

### Tests Added

Created `src/arktype-research.test.ts` with 16 comprehensive tests:
- Question 1: How does arktype generic validation work? (6 tests)
- Question 2: How to validate type strings at compile time? (2 tests)
- Question 3: How does type.infer work? (2 tests)
- Question 4: What types should Stringent support initially? (3 tests)
- Integration pattern for Stringent (2 tests)
- Key findings summary (1 test)

All 750 tests pass. No lint errors.

## Task 8 (PRD Task 2): Create Type Validation Using ArkType (COMPLETED)

Replaced the hardcoded `SchemaToType` with arktype-based validation.

### Implementation

Updated `src/schema/index.ts` with new type utilities:

**1. `ValidArkType<T>` - Compile-Time Type Validation**
```typescript
export type ValidArkType<T extends string> = type.validate<T>;
```
Uses arktype's `type.validate` to validate type strings at compile time.
- Valid types return the type string itself
- Invalid types cause TypeScript compile errors

**2. `ArkTypeSchemaToType<T>` - Direct arktype Inference**
```typescript
export type ArkTypeSchemaToType<T extends string> = type.infer<T>;
```
Direct wrapper around arktype's `type.infer` (no fallback).
- Returns the TypeScript type for valid arktype strings
- Returns `never` for invalid type strings

**3. `SchemaToType<T>` - Backwards-Compatible Inference**
```typescript
export type SchemaToType<T extends string> =
  // Fast path for common primitives
  T extends 'number' ? number
  : T extends 'string' ? string
  : T extends 'boolean' ? boolean
  : T extends 'null' ? null
  : T extends 'undefined' ? undefined
  : T extends 'unknown' ? unknown
  : // Only use arktype for literal strings (not generic 'string')
    string extends T ? unknown
  : SchemaToTypeAdvanced<T>;
```
- Fast path for common primitives to avoid deep type instantiation
- Detects advanced arktype patterns (subtypes, constraints, unions, arrays)
- Falls back to `unknown` for invalid/generic types

### Type Inference Results

The updated `SchemaToType` now correctly infers:
- `'number'` → `number`
- `'string'` → `string`
- `'boolean'` → `boolean`
- `'null'` → `null`
- `'undefined'` → `undefined`
- `'unknown'` → `unknown`
- `'string.email'` → `string` (subtype)
- `'number.integer'` → `number` (subtype)
- `'number >= 0'` → `number` (constraint)
- `'string | number'` → `string | number` (union)
- `'string[]'` → `string[]` (array)
- `'garbage'` → `unknown` (invalid, fallback)

### Tests Added

Created `src/schema/arktype-integration.test.ts` with 32 comprehensive tests:
- SchemaToType - Primitive Types (5 tests)
- SchemaToType - ArkType Subtypes (4 tests)
- SchemaToType - ArkType Constraints (4 tests)
- SchemaToType - Union Types (4 tests)
- ArkTypeSchemaToType - Direct arktype.infer (5 tests)
- ValidArkType - Compile-Time Validation (4 tests)
- SchemaToType - Edge Cases (3 tests)
- SchemaToType - Fallback Behavior (3 tests)

### Known Limitations

1. **Type widening in complex parsers**: When using `parser.parse()` with many nodes,
   the outputSchema type can get widened from literal `"string"` to generic `string`.
   This is a pre-existing limitation (PRD GAP 6) and is documented in the test.

2. **Requires literal type strings**: The arktype inference only works with literal
   string types. Generic `string` types fall back to `unknown` to prevent infinite
   type recursion.

### Files Modified

- `src/schema/index.ts`: Added arktype import, `ValidArkType`, `ArkTypeSchemaToType`,
  updated `SchemaToType`, added `SchemaToTypeAdvanced` and `ArkTypeSchemaToTypeSafe` helpers
- `src/schema/arktype-integration.test.ts`: New test file with 32 tests
- `src/runtime/eval.test.ts`: Updated 1 test to reflect actual type inference behavior

All 783 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 9 (PRD Task 3): Fix Schema Validation in ExprSchema Factories (COMPLETED)

Updated `lhs()`, `rhs()`, `expr()` to validate constraints at compile time using arktype.

### Implementation

Updated `src/schema/index.ts`:

**1. Changed arktype import from type-only to value import:**
```typescript
// Before
import type { type } from 'arktype';

// After
import { type } from 'arktype';
```

**2. Updated function signatures to use `type.validate`:**
```typescript
// Before
export const lhs = <const TConstraint extends string>(constraint?: TConstraint) => ...
export const rhs = <const TConstraint extends string>(constraint?: TConstraint) => ...
export const expr = <const TConstraint extends string>(constraint?: TConstraint) => ...

// After
export const lhs = <const TConstraint extends string>(constraint?: type.validate<TConstraint>) => ...
export const rhs = <const TConstraint extends string>(constraint?: type.validate<TConstraint>) => ...
export const expr = <const TConstraint extends string>(constraint?: type.validate<TConstraint>) => ...
```

### Validation Behavior

**Valid constraints (no type error):**
- Primitives: `'number'`, `'string'`, `'boolean'`, `'null'`, `'undefined'`
- Subtypes: `'string.email'`, `'number.integer'`, `'string.uuid'`
- Constraints: `'number >= 0'`, `'number > 0'`, `'1 <= number <= 100'`
- Unions: `'string | number'`, `'string | number | boolean'`
- Arrays: `'string[]'`, `'number[][]'`
- Other types: `'Date'`, `'bigint'`, `'symbol'`

**Invalid constraints (TypeScript compile error):**
- `lhs('garbage')` - Error: `Argument of type '"garbage"' is not assignable to parameter of type '"'garbage' is unresolvable"'`
- `rhs('asdfghjkl')` - Same type of error
- `expr('notAType')` - Same type of error

### Tests Added

Created `src/schema/constraint-validation.test.ts` with 34 tests:

**lhs() constraint validation (10 tests):**
- accepts valid primitive constraints
- accepts valid arktype subtypes
- accepts valid arktype constraints
- accepts valid union types
- accepts no constraint (unconstrained expression)
- rejects invalid constraint strings (type error)
- preserves constraint type in schema
- works with .as() for named bindings

**rhs() constraint validation (9 tests):**
- Same categories as lhs()

**expr() constraint validation (9 tests):**
- Same categories as lhs()

**defineNode() integration (4 tests):**
- works with validated lhs/rhs constraints in patterns
- works with arktype subtypes in patterns
- works with arktype constraints in patterns
- works with union types in patterns
- rejects invalid constraints in defineNode (type error)

**Edge cases (5 tests):**
- handles array types
- handles complex union types
- handles Date type
- handles bigint type
- handles symbol type

### Files Modified

- `src/schema/index.ts`: Changed arktype import and updated `lhs()`, `rhs()`, `expr()` signatures
- `src/schema/constraint-validation.test.ts`: New test file with 34 tests

All 816 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 10 (PRD Task 4): Fix Schema Validation in defineNode (COMPLETED)

Updated `defineNode()` to validate `resultType` at compile time using arktype.

### Implementation

Updated `src/schema/index.ts`:

**Changed the resultType parameter to use `type.validate`:**
```typescript
// Before
export function defineNode<
  const TName extends string,
  const TPattern extends readonly PatternSchema[],
  const TPrecedence extends Precedence,
  const TResultType extends string,
>(config: {
  // ...
  readonly resultType: TResultType;  // No validation
  // ...
})

// After
export function defineNode<
  const TName extends string,
  const TPattern extends readonly PatternSchema[],
  const TPrecedence extends Precedence,
  const TResultType extends string,
>(config: {
  // ...
  readonly resultType: type.validate<TResultType>;  // Validates at compile time
  // ...
})
```

### Validation Behavior

**Valid resultType values (no type error):**
- Primitives: `'number'`, `'string'`, `'boolean'`, `'null'`, `'undefined'`
- Subtypes: `'string.email'`, `'number.integer'`
- Constraints: `'number >= 0'`, `'1 <= number <= 100'`
- Unions: `'string | number'`, `'string | number | boolean'`
- Arrays: `'string[]'`
- Special: `'unknown'` (for computed types like parentheses)

**Invalid resultType values (TypeScript compile error):**
- `resultType: 'garbage'` - Error: `Type '"garbage"' is not assignable to type '"'garbage' is unresolvable"'`
- `resultType: 'asdfghjkl'` - Same type of error
- `resultType: 'nubmer'` - Same type of error (misspelled)

### Tests Added

Added 10 tests in `src/schema/constraint-validation.test.ts` under "defineNode() resultType validation (Task 4)":

1. accepts valid primitive resultType
2. accepts valid arktype subtype resultType
3. accepts valid arktype constraint resultType
4. accepts valid union resultType
5. accepts array resultType
6. accepts unknown resultType for computed types
7. rejects invalid resultType (type error)
8. rejects another invalid resultType (type error)
9. rejects invalid misspelled resultType (type error)
10. preserves resultType type in NodeSchema

### Files Modified

- `src/schema/index.ts`: Updated `defineNode()` to use `type.validate<TResultType>` for resultType parameter, updated JSDoc
- `src/schema/constraint-validation.test.ts`: Added 10 tests for resultType validation

All 826 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 11 (PRD Task 5): Fix Schema Validation in parser.parse() (COMPLETED)

Updated `parser.parse()` to validate schema types at compile time using arktype.

### Implementation

Updated `src/createParser.ts`:

**1. Added `ValidatedSchema` type:**
```typescript
type ValidatedSchema<TSchema extends Record<string, string>> = {
  [K in keyof TSchema]: string extends TSchema[K]
    ? string // Skip validation for generic string values
    : type.validate<TSchema[K]>; // Validate literal string values
};
```

**2. Updated Parser interface:**
```typescript
parse<TInput extends string, TSchema extends Record<string, string>>(
  input: ValidatedInput<TGrammar, TInput, Context<TSchema>>,
  schema: ValidatedSchema<TSchema>
): Parse<TGrammar, TInput, Context<TSchema>>;
```

**3. Updated createParser implementation:**
```typescript
parse<TInput extends string, TSchema extends Record<string, string>>(
  input: TInput,
  schema: ValidatedSchema<TSchema>
): Parse<ComputeGrammar<TNodes>, TInput, Context<TSchema>> { ... }
```

### Validation Behavior

**Valid schema types (no type error):**
- Primitives: `'number'`, `'string'`, `'boolean'`, `'null'`, `'undefined'`
- Subtypes: `'string.email'`, `'number.integer'`, `'string.uuid'`, `'string.url'`
- Constraints: `'number >= 0'`, `'number > 0'`, `'1 <= number <= 100'`, `'string >= 8'`
- Unions: `'string | number'`, `'string | number | boolean'`, `'null | string'`
- Arrays: `'string[]'`, `'number[]'`
- Other types: `'Date'`, `'bigint'`, `'symbol'`, `'unknown'`

**Invalid schema types (TypeScript compile error):**
- `parser.parse('x', { x: 'garbage' })` - Error: `Type '"garbage"' is not assignable to type '"'garbage' is unresolvable"'`
- `parser.parse('x', { x: 'asdfghjkl' })` - Same type of error
- `parser.parse('x', { x: 'nubmer' })` - Same type of error (misspelled)
- `parser.parse('x', { x: 'string.invalid' })` - Same type of error (invalid subtype)

### Key Design Decisions

1. **Generic string handling:** When schema values are generic `string` type (not literal strings), validation is skipped to avoid deep type instantiation issues with arktype's `type.validate`.

2. **Mapped type validation:** Uses a mapped type that transforms each schema value through `type.validate<T>` for literal types.

3. **Runtime cast:** The implementation casts `schema as TSchema` to maintain the original type for downstream usage while the parameter type enforces validation.

### Tests Added

Created `src/createParser.schema-validation.test.ts` with 34 tests:

**Valid types (24 tests):**
- accepts primitive type strings (5 tests)
- accepts arktype subtypes (4 tests)
- accepts arktype constraints (4 tests)
- accepts union types (3 tests)
- accepts array types (2 tests)
- accepts other valid types (4 tests)
- accepts empty schema (1 test)
- accepts multiple schema entries (1 test)

**Invalid types - type errors (8 tests):**
- rejects garbage type string
- rejects asdfghjkl type string
- rejects misspelled number
- rejects misspelled string
- rejects invalid subtype
- rejects invalid constraint syntax
- rejects random text
- rejects partially invalid schema

**Type preservation tests (2 tests):**
- preserves literal schema types
- works with as const assertions

### Bug Fix

Fixed pre-existing bug in `src/schema/constraint-validation.test.ts:462` where `precedence: 'atom'` was used instead of a number (Precedence type is `number`).

### Files Modified

- `src/createParser.ts`: Added arktype import, `ValidatedSchema` type, updated `Parser.parse()` and `createParser()` implementation
- `src/createParser.schema-validation.test.ts`: New test file with 34 tests
- `src/schema/constraint-validation.test.ts`: Fixed bug (changed `precedence: 'atom'` to `precedence: 0`)

All 860 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 12 (PRD Task 6 completion): Add Runtime ArkType Validation (COMPLETED)

Completed the deferred item from Task 6: "Add runtime validation using arktype".

### Implementation

Updated `src/runtime/eval.ts`:

**1. Added arktype import:**
```typescript
import { type, Type } from 'arktype';
```

**2. Added validator caching for performance:**
```typescript
const validatorCache = new Map<string, Type>();

function getValidator(schema: string): Type {
  let validator = validatorCache.get(schema);
  if (!validator) {
    validator = type(schema as never) as Type;
    validatorCache.set(schema, validator);
  }
  return validator;
}
```

**3. Added validation function:**
```typescript
function validateValue(value: unknown, schema: string, variableName: string): void {
  if (schema === 'unknown' || schema === 'never') {
    return; // Skip validation for generic schemas
  }

  const validator = getValidator(schema);
  const result = validator(value);

  if (result instanceof type.errors) {
    throw new Error(
      `Variable '${variableName}' failed validation for schema '${schema}': ${result.summary}`
    );
  }
}
```

**4. Integrated validation into identifier evaluation:**
```typescript
// Handle identifier nodes - look up value in context and validate against schema
if (nodeType === 'identifier') {
  // ... existing code to get name and value ...

  // Validate value against arktype schema at runtime
  if ('outputSchema' in node && typeof node.outputSchema === 'string') {
    validateValue(value, node.outputSchema, name);
  }

  return value as ReturnType;
}
```

### Runtime Validation Behavior

**Now the evaluator validates identifier values against their arktype schemas:**

- `'number >= 0'` - Throws if value is negative
- `'number > 0'` - Throws if value is zero or negative
- `'number.integer'` - Throws if value is not an integer
- `'1 <= number <= 100'` - Throws if value is out of range
- `'string.email'` - Throws if value is not a valid email
- `'string.uuid'` - Throws if value is not a valid UUID
- `'string >= 8'` - Throws if string length is less than 8
- `'string | number'` - Throws if value is neither string nor number
- Basic type constraints - Throws if value doesn't match type

### Tests Added

Added 27 new tests in `src/runtime/eval.test.ts` under "evaluate - runtime arktype constraint validation":

**Number constraints (7 tests):**
- validates number >= 0 constraint - accepts valid value
- validates number >= 0 constraint - accepts zero
- validates number >= 0 constraint - rejects negative value
- validates number > 0 constraint - rejects zero
- validates number.integer constraint - rejects float
- validates number.integer constraint - accepts integer
- validates range constraint 1 <= number <= 100

**String constraints (6 tests):**
- validates string.email constraint - accepts valid email
- validates string.email constraint - rejects invalid email
- validates string.uuid constraint - accepts valid uuid
- validates string.uuid constraint - rejects invalid uuid
- validates string length constraint - rejects too short
- validates string length constraint - accepts valid length

**Basic type constraints (5 tests):**
- validates number type - rejects string
- validates string type - rejects number
- validates boolean type - rejects string
- validates null type - rejects undefined
- validates undefined type - rejects null

**Union type constraints (3 tests):**
- validates string | number union - accepts string
- validates string | number union - accepts number
- validates string | number union - rejects boolean

**Parsed expressions with constraints (3 tests):**
- validates parsed identifier with number >= 0 constraint
- validates parsed identifier with string.email constraint
- validates parsed expression with two constrained identifiers

**createEvaluator with constraints (1 test):**
- validates constraint in createEvaluator

**Edge cases (2 tests):**
- skips validation for unknown schema
- validates nested identifier in expression

### Existing Test Updates

Updated 2 existing tests that now throw runtime errors in addition to type errors:
- "rejects wrong data types (type error)" → "rejects wrong data types (type error and runtime error)"
- Updated both in evaluate() and createEvaluator() sections

### Files Modified

- `src/runtime/eval.ts`: Added arktype import, validator cache, validateValue function, integrated validation into identifier handling
- `src/runtime/eval.test.ts`: Added 27 new tests, updated 2 existing tests

All 887 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 13 (PRD Task 7): Add Type-Level and Runtime Tests (COMPLETED)

Created a comprehensive test file that consolidates all type safety tests for the PRD Task 7 requirements.

### Implementation

Created `src/comprehensive-type-safety.test.ts` with 42 tests organized into 4 main sections:

**1. Type Tests for Schema Validation**
- Tests that invalid schema types cause compile-time errors via `@ts-expect-error`
- Tests for `parser.parse()` with invalid types like 'garbage'
- Tests for `lhs()`, `rhs()`, `expr()` constraint validation
- Tests for `defineNode()` resultType validation
- Tests for valid arktype types (primitives, subtypes, constraints, unions)

**2. Type Tests for Data Validation**
- Tests that `evaluate()` requires correct data types for identifiers
- Tests that missing variables cause type errors
- Tests that wrong data types cause type errors
- Tests that extra properties in data are allowed
- Tests that literal-only expressions accept empty data

**3. Runtime Tests for ArkType Constraint Validation**
- Number constraint tests: `number >= 0`, `number > 0`, `number.integer`, range constraints
- String constraint tests: `string.email`, `string.uuid`, string length constraints
- Basic type constraint tests: number/string/boolean type validation
- Union type constraint tests: `string | number` union validation
- Nested identifier validation in expressions
- Edge cases: 'unknown' schema skips validation

**4. Tests for ArkType Subtypes**
- `string.email` format validation with valid/invalid values
- `string.uuid` format validation with valid/invalid values
- `string.url` format validation
- `number.integer` validation with integers vs floats
- Standalone identifier constraint validation

### Test Coverage Summary

| Requirement | Test Count | Description |
|-------------|------------|-------------|
| Schema validation (type errors) | 10 | Compile-time rejection of invalid types |
| Schema validation (valid types) | 8 | Acceptance of valid arktype types |
| Data validation (type errors) | 5 | Type-level data-schema connection |
| Runtime constraint validation | 16 | Runtime arktype constraint enforcement |
| ArkType subtypes | 6 | Subtype-specific validation |
| Edge cases | 3 | Special scenarios |

### Notes

The comprehensive test file follows the exact patterns shown in the PRD Task 7 specification:
- Uses `@ts-expect-error` for compile-time type tests
- Uses `expect().toThrow()` for runtime validation tests
- Tests both type-level and runtime behavior where applicable
- Uses manually constructed ASTs with `as const` for precise type-level testing
- Uses parser output for runtime behavior testing

### Pre-existing Test Coverage

The following files also contain related tests that existed before Task 7:
- `src/createParser.schema-validation.test.ts` (34 tests for schema validation)
- `src/schema/constraint-validation.test.ts` (44 tests for constraint validation)
- `src/schema/arktype-integration.test.ts` (32 tests for arktype integration)
- `src/runtime/eval.test.ts` (27+ tests for runtime constraint validation)

### Files Modified

- `src/comprehensive-type-safety.test.ts`: New comprehensive test file with 42 tests
- `PRD.md`: Marked Task 7 checkboxes as complete

All 929 tests pass. No new lint errors.

## Task 14 (PRD Task 8): Fix Evaluate Return Type with ArkType (COMPLETED)

Verified and tested that `evaluate()` and `createEvaluator()` correctly infer return types from the AST's `outputSchema` field using arktype's type inference.

### Implementation

The `SchemaToType<T>` type (implemented in Task 2) already correctly uses arktype's `type.infer<T>` for advanced types. The `evaluate()` function uses `SchemaToType<ExtractOutputSchema<T>>` for its return type, which means it automatically supports all valid arktype types.

**Return Type Inference Works For:**

1. **Primitives:**
   - `outputSchema: 'number'` → returns `number`
   - `outputSchema: 'string'` → returns `string`
   - `outputSchema: 'boolean'` → returns `boolean`
   - `outputSchema: 'null'` → returns `null`
   - `outputSchema: 'undefined'` → returns `undefined`

2. **ArkType Subtypes:**
   - `outputSchema: 'string.email'` → returns `string`
   - `outputSchema: 'string.uuid'` → returns `string`
   - `outputSchema: 'string.url'` → returns `string`
   - `outputSchema: 'number.integer'` → returns `number`

3. **ArkType Constraints:**
   - `outputSchema: 'number >= 0'` → returns `number`
   - `outputSchema: 'number > 0'` → returns `number`
   - `outputSchema: '1 <= number <= 100'` → returns `number`
   - `outputSchema: 'string >= 8'` → returns `string`

4. **Union Types:**
   - `outputSchema: 'string | number'` → returns `string | number`
   - `outputSchema: 'boolean | number'` → returns `boolean | number`
   - `outputSchema: 'string | number | boolean'` → returns `string | number | boolean`
   - `outputSchema: 'null | undefined'` → returns `null | undefined`

5. **Array Types:**
   - `outputSchema: 'string[]'` → returns `string[]`
   - `outputSchema: 'number[]'` → returns `number[]`
   - `outputSchema: '(string | number)[]'` → returns `(string | number)[]`

### Tests Added

Added 28 comprehensive type-level tests in `src/runtime/eval.test.ts` under "evaluate - return type inference with arktype (Task 8)":

**Primitive Types (5 tests):**
- infers number return type from outputSchema: "number"
- infers string return type from outputSchema: "string"
- infers boolean return type from outputSchema: "boolean"
- infers null return type from outputSchema: "null"
- infers undefined return type from outputSchema: "undefined"

**ArkType Subtypes (4 tests):**
- infers string return type from outputSchema: "string.email"
- infers string return type from outputSchema: "string.uuid"
- infers string return type from outputSchema: "string.url"
- infers number return type from outputSchema: "number.integer"

**ArkType Constraints (4 tests):**
- infers number return type from outputSchema: "number >= 0"
- infers number return type from outputSchema: "number > 0"
- infers number return type from outputSchema: "1 <= number <= 100"
- infers string return type from outputSchema: "string >= 8"

**Union Types (4 tests):**
- infers string | number return type from outputSchema: "string | number"
- infers boolean | number return type from outputSchema: "boolean | number"
- infers string | number | boolean return type from outputSchema: "string | number | boolean"
- infers null | undefined return type from outputSchema: "null | undefined"

**Array Types (3 tests):**
- infers string[] return type from outputSchema: "string[]"
- infers number[] return type from outputSchema: "number[]"
- infers (string | number)[] return type from outputSchema: "(string | number)[]"

**createEvaluator Tests (3 tests):**
- infers string return type for subtype
- infers number return type for constraint
- infers union return type

### Key Insight

Task 8 was already functionally complete from Task 2's implementation of `SchemaToType`. The task verification confirmed that:
1. The `SchemaToType` type correctly uses arktype's `type.infer<T>` for advanced types
2. The `evaluate()` function's return type (`SchemaToType<ExtractOutputSchema<T>>`) automatically benefits from this
3. Both compile-time type inference and runtime behavior work correctly

### Files Modified

- `src/runtime/eval.test.ts`: Added 28 type-level tests for return type inference
- `PRD.md`: Marked Task 8 checkboxes as complete, added implementation notes

All 952 tests pass. No new lint errors (only pre-existing warnings).

## Task 15 (PRD Task 9 - Part A): Single-Binding OutputSchema Propagation (COMPLETED)

Fixed the type/runtime mismatch for single-binding nodes (e.g., parentheses). The type-level `BuildNodeResult` now matches the runtime behavior that was already implemented.

### Problem

The runtime parser already propagated `outputSchema` for single-binding nodes:
```typescript
// Runtime (src/runtime/parser.ts:598-612)
if (outputSchema === 'unknown') {
  if (bindingKeys.length === 1) {
    outputSchema = singleBinding.outputSchema;  // Propagates!
  }
}
```

But the type-level code always used the static `resultType`:
```typescript
// Type-level (before fix)
readonly outputSchema: TNode['resultType'];  // Always static!
```

This meant `(1 + 2)` returned:
- Runtime: `outputSchema = 'number'` ✓
- Type-level: `outputSchema = 'unknown'` ✗

### Implementation

Added helper types in `src/parse/index.ts`:

**1. `HasExactlyOneKey<T>`** - Checks if a type has exactly one key:
```typescript
type HasExactlyOneKey<T> = keyof T extends infer K
  ? K extends unknown
    ? [K] extends [keyof T]
      ? keyof T extends K
        ? true
        : false
      : false
    : false
  : false;
```

**2. `SingleKey<T>`** - Gets the single key from a type with exactly one key:
```typescript
type SingleKey<T> = keyof T extends infer K
  ? K extends keyof T
    ? keyof T extends K
      ? K
      : never
    : never
  : never;
```

**3. `SingleBindingOutputSchema<Bindings>`** - Extracts outputSchema from the single binding:
```typescript
type SingleBindingOutputSchema<Bindings> =
  HasExactlyOneKey<Bindings> extends true
    ? SingleKey<Bindings> extends infer K
      ? K extends keyof Bindings
        ? Bindings[K] extends { outputSchema: infer S extends string }
          ? S
          : 'unknown'
        : 'unknown'
      : 'unknown'
    : 'unknown';
```

**4. `ComputeOutputSchema<TResultType, Bindings>`** - Computes the effective outputSchema:
```typescript
type ComputeOutputSchema<TResultType extends string, Bindings> =
  TResultType extends 'unknown'
    ? SingleBindingOutputSchema<Bindings> extends infer S extends string
      ? S extends 'unknown'
        ? 'unknown'
        : S
      : 'unknown'
    : TResultType;
```

**5. Updated `BuildNodeResult`** to use `ComputeOutputSchema`:
```typescript
type BuildNodeResult<TNode extends NodeSchema, TChildren extends unknown[]> =
  ExtractBindings<TNode['pattern'], TChildren> extends infer Bindings
    ? keyof Bindings extends never
      ? TChildren extends [infer Only]
        ? Only
        : never
      : {
          readonly node: TNode['name'];
          readonly outputSchema: ComputeOutputSchema<TNode['resultType'], Bindings>;
        } & Bindings
    : never;
```

### Tests Added

Added 12 tests in `src/runtime/eval.test.ts` under "single-binding outputSchema propagation (Task 9)":

**Type-level propagation (9 tests):**
- propagates outputSchema through parentheses for number expression
- propagates outputSchema through parentheses for string expression
- propagates outputSchema through parentheses for boolean expression
- propagates outputSchema through nested parentheses
- propagates outputSchema through triple nested parentheses
- propagates outputSchema through parentheses with comparison
- propagates outputSchema in complex expression with parentheses
- propagates outputSchema for parenthesized null
- propagates outputSchema for parenthesized undefined

**Helper type tests (1 test):**
- propagates type for single-binding node with resultType: unknown

**Multi-binding behavior (1 test):**
- ternary with two bindings keeps resultType unknown

**createEvaluator integration (1 test):**
- propagates type through createEvaluator for parenthesized expression

### Test Updates

Updated 2 existing tests that were documenting the old (broken) behavior:
- "handles parentheses - compile-time type is unknown" → "handles parentheses - type propagates from inner expression (Task 9 fix)"
- "handles deeply nested parentheses - compile-time type is unknown" → "handles deeply nested parentheses - type propagates through all levels (Task 9 fix)"

### Results

This completes PRD Acceptance Criteria #12 and #14:
- ✅ Parentheses `(1 + 2)` has `outputSchema: 'number'` at BOTH runtime and type-level
- ✅ `evaluate()` returns `number` for `(1 + 2)`

Remaining for Task 9 (Part B - Union Computation):
- ❌ #13: Ternary `x ? true : 0` has `outputSchema: 'boolean | number'`
- ❌ #15: `evaluate()` returns `boolean | number` for ternary `x ? true : 0`

### Files Modified

- `src/parse/index.ts`: Added helper types, updated `BuildNodeResult`
- `src/runtime/eval.test.ts`: Added 12 new tests, updated 2 existing tests

All 964 tests pass. TypeScript type checking passes. No new lint errors (only pre-existing warnings).

## Task 16 (PRD Task 9 - Part B): Union Type Computation for Multi-Binding Nodes (COMPLETED)

Implemented computed union result types for multi-binding nodes like ternary. Nodes can now use `resultType: { union: ['bindingA', 'bindingB'] }` to have their `outputSchema` computed as the union of the specified bindings' outputSchemas.

### Design

**New Types in `src/schema/index.ts`:**

```typescript
// Marker for computed union result types
interface UnionResultType<TBindings extends readonly string[] = readonly string[]> {
  readonly union: TBindings;
}

// Result type specification (static string or computed union)
type ResultTypeSpec<T extends string | UnionResultType = string | UnionResultType> = T;
```

**Updated `NodeSchema` interface:**
- Changed `TResultType extends string` to `TResultType extends string | UnionResultType`

**Updated `defineNode()` function:**
- Added function overload for `UnionResultType` result types
- Static string result types are validated by arktype at compile time
- `UnionResultType` result types skip arktype validation (computed at parse time)

### Type-Level Implementation (`src/parse/index.ts`)

Added new helper types:

```typescript
// Extract outputSchema from a binding by name
type BindingOutputSchema<Bindings, TName extends string> = ...

// Compute union of outputSchemas from multiple bindings
type ComputeUnionOutputSchema<Bindings, TNames extends readonly string[], TAcc> = ...
```

Updated `ComputeOutputSchema` to:
1. Check if `resultType` is a `UnionResultType`
2. If so, use `ComputeUnionOutputSchema` to collect all binding outputSchemas into a TypeScript union
3. Otherwise, use existing behavior (single-binding propagation or static resultType)

### Runtime Implementation (`src/runtime/parser.ts`)

Added helper functions:

```typescript
// Check if resultType is a UnionResultType
function isUnionResultType(resultType: string | UnionResultType): resultType is UnionResultType

// Compute union string from bindings (e.g., 'boolean | number')
function computeUnionOutputSchema(bindings: Record<string, ASTNode>, names: readonly string[]): string
```

Updated `buildNodeResult`:
- Detects `UnionResultType` via `isUnionResultType()`
- Computes union string by extracting schemas from named bindings
- Deduplicates and sorts schemas alphabetically before joining with ' | '

### Usage Example

```typescript
// Define a ternary node with computed union result type
const ternary = defineNode({
  name: 'ternary',
  pattern: [
    lhs('boolean').as('condition'),
    constVal('?'),
    expr().as('then'),
    constVal(':'),
    rhs().as('else'),
  ],
  precedence: 0,
  resultType: { union: ['then', 'else'] } as const, // Computed union
  eval: ({ condition, then: thenVal, else: elseVal }) => (condition ? thenVal : elseVal),
});

// Parsing 'true ? 1 : "hello"' results in:
// outputSchema = 'number | string' (computed from branches)

// Type-level inference works:
const value = evaluate(ast, ctx);
// TypeScript infers: value is string | number
```

### Tests Added

Added 15 tests in `src/runtime/eval.test.ts` under "union type computation (Task 9 Part B)":

**Runtime union type computation (6 tests):**
- computes union for ternary with number and string branches
- computes union for ternary with boolean and number branches
- computes single type when both branches have same type
- computes union for ternary with string and boolean branches
- computes union with expressions in branches
- computes union for nested ternary

**Type-level union type computation (5 tests):**
- infers union type for ternary with number and string branches
- infers union type for ternary with boolean and number branches
- infers single type when both branches have same type
- infers union type with expressions in branches
- infers union type with manually constructed AST

**createEvaluator with union types (2 tests):**
- infers union type through createEvaluator
- infers union type for nested ternary through createEvaluator

**Edge cases (2 tests):**
- handles union when one branch has unknown schema
- defineNode accepts union result type marker

### Acceptance Criteria Completed

This completes PRD Acceptance Criteria #13 and #15:
- ✅ #13: Ternary `x ? true : 0` has `outputSchema: 'boolean | number'`
- ✅ #15: `evaluate()` returns `boolean | number` for ternary `x ? true : 0`

### Files Modified

- `src/schema/index.ts`: Added `UnionResultType`, `ResultTypeSpec`, updated `NodeSchema`, added `defineNode` overloads
- `src/parse/index.ts`: Added import, `BindingOutputSchema`, `ComputeUnionOutputSchema`, updated `ComputeOutputSchema`
- `src/runtime/parser.ts`: Added import, `isUnionResultType()`, `computeUnionOutputSchema()`, updated `buildNodeResult()`
- `src/runtime/eval.test.ts`: Added 15 new tests, updated 1 existing test comment

All 979 tests pass. TypeScript type checking passes. No new lint errors (only pre-existing warnings).

## Task 17 (PRD Task 10): Update Documentation (COMPLETED)

Updated README.md and docs/api-reference.md to document the ArkType integration that was implemented in Tasks 1-9.

### README.md Updates

**1. Overview section:**
- Added key features highlighting ArkType integration, full type inference, constraint validation, and computed result types
- Added link to ArkType homepage

**2. New "ArkType Integration" section with:**
- **Supported ArkType Types table:** Primitives, subtypes, constraints, unions, arrays with TypeScript mappings
- **Compile-Time Schema Validation:** Examples showing `parser.parse()` validation with valid/invalid types
- **Compile-Time Constraint Validation:** Examples for `lhs()`, `rhs()`, `expr()` with `@ts-expect-error` patterns
- **Runtime Data Validation:** Examples showing ArkType constraint validation at runtime
- **ArkType Subtype Validation:** Examples with `string.email` format validation
- **Computed Union Result Types:** Examples showing `{ union: [...] }` syntax for ternary-like nodes
- **Type-Safe Data Requirements:** Examples showing `evaluate()` data-schema connection

**3. Key Features section:**
- Added ArkType Integration bullet point
- Added runtime constraint validation bullet point
- Added computed result types bullet point
- Updated compile-time validation to mention type strings

### docs/api-reference.md Updates

**1. Table of Contents:**
- Added ArkType Integration section with Supported Types, Compile-Time Validation, Runtime Validation, Computed Result Types

**2. defineNode() section:**
- Updated `resultType` parameter type to `string | UnionResultType`
- Added "resultType Validation" subsection showing ArkType validation
- Added "Computed Union Result Types" subsection with ternary example

**3. Expression Factories section (lhs, rhs, expr):**
- Updated constraint parameter type to `type.validate<T>?`
- Added "Constraint Validation" notes showing ArkType validation examples

**4. evaluate() section:**
- Expanded return type table to include subtypes, constraints, unions, arrays
- Updated signature to show `ExtractRequiredData<T>` constraint
- Updated Type Utilities to show ArkType-based `SchemaToType` implementation

**5. New "ArkType Integration" section with:**
- **Supported Types:** Full table of supported ArkType types
- **Compile-Time Validation:** Examples for schema, constraint, and resultType validation
- **Runtime Validation:** Examples for constraint, subtype, and type validation
- **Computed Result Types:** Documentation of `UnionResultType` with ternary example
- **Single-Binding Propagation:** Documentation of automatic outputSchema propagation

**6. Type-Level Utilities section:**
- Updated `SchemaToType<T>` to show ArkType-based implementation with examples
- Added `ValidArkType<T>` documentation
- Added `UnionResultType<TBindings>` documentation

### Files Modified

- `README.md`: Added ArkType Integration section, updated Key Features, updated overview
- `docs/api-reference.md`: Added ArkType Integration section, updated defineNode, expression factories, evaluate, and type utilities

All 979 tests pass. No new lint errors (only pre-existing warnings).

## Task 18 (PRD Task 11): Support Nested Object Schemas (COMPLETED)

Enabled nested object schema support in `parser.parse()`. Users can now pass nested object schemas like `{ user: { name: 'string', age: 'number' } }` and get compile-time validation.

### Problem

The custom `ValidatedSchema` type in `createParser.ts` used a recursive mapped type with intersections:
```typescript
type ValidateSchemaValue<T> = T extends string
  ? type.validate<T>
  : T extends object
    ? { [K in keyof T]: ValidateSchemaValue<T[K] & SchemaValue> }
    : never;
```

The intersection `T[K] & SchemaValue` caused TypeScript union distribution issues. For nested objects like `{ user: { name: 'string' } }`, the intersection created:
- `(T[K] & string) | (T[K] & { ... })`

This broke validation for nested objects because the union distribution prevented proper constraint checking.

### Solution

Discovered that ArkType's native `type.validate<T>` already handles nested object validation correctly:
```typescript
function test<const T>(schema: type.validate<T>) { ... }
test({ user: { name: 'string' } }); // Works!
test({ user: { name: 'garbage' } }); // Compile error!
```

Updated `createParser.ts` to delegate directly to ArkType instead of using a custom recursive type:

```typescript
// Before: Custom recursive type with union distribution bug
type ValidatedSchema<TSchema extends Record<string, string>> = {
  [K in keyof TSchema]: string extends TSchema[K]
    ? string
    : type.validate<TSchema[K]>;
};

// After: Delegate to arktype's native validation
export interface Parser<TGrammar extends Grammar, TNodes extends readonly NodeSchema[]> {
  parse<TInput extends string, const TSchema extends SchemaRecord>(
    input: ValidatedInput<TGrammar, TInput, Context<TSchema>>,
    schema: type.validate<TSchema>
  ): Parse<TGrammar, TInput, Context<TSchema>>;
  readonly nodes: TNodes;
}
```

Key changes:
1. Changed schema constraint from `Record<string, string>` to `SchemaRecord` (which allows nested objects)
2. Used `type.validate<TSchema>` directly instead of custom `ValidatedSchema<TSchema>`
3. Removed the custom `ValidateSchemaValue` type entirely

### Tests Added

Created `src/nested-object-test.test.ts` with 7 tests:

**ArkType native nested object support (2 tests):**
- type() accepts nested object schemas
- type.validate accepts nested object schemas in generic functions

**parser.parse() with nested object schemas (5 tests):**
- accepts nested object in schema
- rejects invalid nested schema values (`@ts-expect-error`)
- accepts deeply nested schemas (3 levels deep)
- rejects invalid types in deeply nested schemas (`@ts-expect-error`)
- accepts mixed flat and nested schemas

### Validation Behavior

**Valid nested schemas (no type error):**
```typescript
parser.parse('user', { user: { name: 'string', age: 'number' } });
parser.parse('data', { data: { level1: { level2: { value: 'boolean' } } } });
parser.parse('x', { x: 'number', user: { name: 'string' } }); // Mixed
```

**Invalid nested schemas (TypeScript compile error):**
```typescript
// @ts-expect-error - 'garbage' is not a valid arktype type
parser.parse('user', { user: { name: 'garbage' } });

// @ts-expect-error - 'invalid' is not a valid arktype type
parser.parse('data', { data: { level1: { level2: { value: 'invalid' } } } });
```

### Files Modified

- `src/createParser.ts`: Updated `Parser` interface and `createParser()` to use `type.validate<TSchema>` directly
- `src/nested-object-test.test.ts`: New test file with 7 tests
- `src/runtime/eval.test.ts`: Fixed test that was accidentally broken during debugging

All 986 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 19 (PRD Task 12): Parser Returns Bound Evaluator (COMPLETED)

Changed `parser.parse()` to return a bound evaluator instead of a raw `[AST, '']` tuple. The new API is more ergonomic and captures all necessary context.

### Old API

```typescript
const result = parser.parse('x + 1', { x: 'number' });
const value = evaluate(result[0], { data: { x: 5 }, nodes: [add, mul] });
```

### New API

```typescript
const [evaluator, err] = parser.parse('x + 1', { x: 'number' });
if (!err) {
  const value = evaluator({ x: 5 });  // Returns number
  console.log(evaluator.ast);          // Access the parsed AST
  console.log(evaluator.schema);       // Access the schema used
}
```

### Implementation

**New Types in `src/createParser.ts`:**

```typescript
// Extract outputSchema from AST for return type inference
type ExtractOutputSchema<T> = T extends { outputSchema: infer S extends string } ? S : 'unknown';

// Convert schema record to TypeScript data types
type SchemaRecordToData<TSchema extends SchemaRecord> = {
  [K in keyof TSchema]: TSchema[K] extends string
    ? SchemaToType<TSchema[K]>
    : TSchema[K] extends SchemaRecord
      ? SchemaRecordToData<TSchema[K]>
      : unknown;
};

// Bound evaluator returned by parser.parse()
interface Evaluator<TAST, TSchema extends SchemaRecord> {
  (data: SchemaRecordToData<TSchema>): SchemaToType<ExtractOutputSchema<TAST>>;
  readonly ast: TAST;
  readonly schema: TSchema;
}

// Parse result: [Evaluator, null] on success, [null, Error] on failure
type ParseResult<TAST, TSchema extends SchemaRecord> =
  | [Evaluator<TAST, TSchema>, null]
  | [null, Error];
```

**Runtime Implementation:**

1. Parse the input using existing `runtimeParse()`
2. Check for parse failures (non-array result or non-empty remaining input)
3. Create a bound evaluator function that:
   - Validates data against the schema using ArkType
   - Calls `evaluate()` with the captured AST and nodes
4. Attach `ast` and `schema` properties to the evaluator
5. Return `[evaluator, null]` on success, `[null, Error]` on failure

**Data Validation:**

- Added `validatorCache` to cache ArkType validators by schema key
- Added `getValidator()` to get or create validators
- Added `validateData()` to validate data against the schema at runtime
- Throws `Error` with ArkType error summary if validation fails

### Tests Added

Created `src/createParser.bound-evaluator.test.ts` with 24 tests covering:

**Parse Return Type:**
- Returns tuple with evaluator and null on success
- Returns tuple with null and error on parse failure
- Returns tuple with null and error for invalid expression

**Evaluator Properties:**
- evaluator.ast contains the parsed AST
- evaluator.schema contains the schema used for parsing

**Evaluator Call Signature:**
- Evaluator is callable with data
- Evaluator returns correct value for simple expression
- Evaluator returns correct value for expression with variables
- Evaluator works with string expressions
- Evaluator works with boolean expressions

**Type Safety:**
- Evaluator return type is inferred from AST outputSchema
- Evaluator data parameter is type-safe
- Evaluator works with complex schemas (nested, constraints, subtypes)

**Runtime Data Validation:**
- Evaluator validates data against schema at runtime
- Evaluator throws for invalid data types
- Evaluator throws for constraint violations (number >= 0)
- Evaluator throws for subtype violations (string.email)

**Error Handling:**
- Parse error includes useful message
- Parse error for empty remaining input

### Test Migration

Updated all existing tests to use the new API:

- `createParser.test.ts`: 13 tests updated
- `eval.test.ts`: 196 tests updated
- `createParser.schema-validation.test.ts`: 33 tests updated
- `comprehensive-type-safety.test.ts`: 10 tests updated
- `type-safety.test.ts`: 48 tests updated
- `string-escapes.test.ts`: 15 tests updated
- `nested-object-test.test.ts`: 5 tests updated
- `inference.test.ts`: 10 tests updated
- `primitive-literals.test.ts`: 20 tests updated

### Documentation Updates

**README.md:**
- Updated Quick Start examples to use new API
- Updated Type-Safe Evaluation section
- Updated Runtime Data Validation section
- Updated all example code throughout
- Updated API Reference section

**docs/api-reference.md:**
- Updated createParser() example
- Updated evaluate() section
- Updated createEvaluator() section (marked as lower-level API)
- Added Parser interface documentation with ParseResult and Evaluator types

### Files Modified

- `src/createParser.ts`: Major refactoring for bound evaluator API
- `src/createParser.bound-evaluator.test.ts`: New test file (24 tests)
- `src/createParser.test.ts`: Updated to new API
- `src/runtime/eval.test.ts`: Updated to new API
- `src/createParser.schema-validation.test.ts`: Updated to new API
- `src/comprehensive-type-safety.test.ts`: Updated to new API
- `src/type-safety.test.ts`: Updated to new API
- `src/string-escapes.test.ts`: Updated to new API
- `src/nested-object-test.test.ts`: Updated to new API
- `src/inference.test.ts`: Updated to new API
- `src/primitive-literals.test.ts`: Updated to new API
- `README.md`: Updated documentation
- `docs/api-reference.md`: Updated documentation

All 1011 tests pass. TypeScript type checking passes. Lint passes (warnings only).
