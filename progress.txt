# Stringent v2 - Type Inference Fix Progress

## Task 1: Understanding the Codebase (COMPLETED)

### What is the `outputSchema` field on AST nodes? Where does it come from?

The `outputSchema` field is defined in `src/primitive/index.ts:31-34`:
```typescript
export interface ASTNode<TType extends string = string, TOutputSchema = unknown> {
  node: TType;
  outputSchema: TOutputSchema;
}
```

It represents the string type of the result (e.g., "number", "string", "boolean"). It comes from:
1. **Literal nodes**: Set by runtime parsers (e.g., `outputSchema: 'number'` for number literals)
2. **Identifier nodes**: Set from context data type (e.g., `ctx.data[name]`)
3. **Operator nodes**: Set from `nodeSchema.resultType` during `buildNodeResult()`

### How does `parser.parse()` preserve type information from input to output?

The parser uses a dual-track architecture:
1. **Compile-time**: The `Parse<TGrammar, TInput, Context>` type computes exact result types by tokenizing input and building typed AST nodes
2. **Runtime**: The runtime parser mirrors this structure, setting `outputSchema` fields correctly

The `createParser()` function casts runtime results to match compile-time types.

### What existing type utilities does the codebase have for mapping schema strings to TypeScript types?

In `src/schema/index.ts`:
- `SchemaToType<T>`: Maps "number" → number, "string" → string, etc.
- `InferNodeType<TSchema>`: Maps schema to AST node type
- `InferEvaluatedType<TSchema>`: Maps schema to runtime value type
- `InferBindings<TPattern>`: Extracts AST node types from pattern
- `InferEvaluatedBindings<TPattern>`: Extracts evaluated value types from pattern

### Why does the current `evaluate()` function lose type information?

The original function signature was:
```typescript
export function evaluate(ast: unknown, ctx: EvalContext): unknown
```

- Input type is `unknown` - TypeScript can't see the `outputSchema` field
- No type parameter captures the AST type
- Return type is hardcoded to `unknown`

## Task 2: Fix `evaluate()` Return Type (COMPLETED)

Fixed in `src/runtime/eval.ts`:
```typescript
type ExtractOutputSchema<T> = T extends { outputSchema: infer S extends string } ? S : 'unknown';

export function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>> {
  // Implementation unchanged, just casts to the inferred return type
}
```

Now when you call `evaluate()` with an AST that has `outputSchema: "number"`, the return type is `number`.

## Task 3: Fix `createEvaluator()` Return Type (COMPLETED)

Updated in `src/runtime/eval.ts`:
```typescript
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends Record<string, unknown>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>> {
    return evaluate(ast, { data, nodes });
  };
}
```

## Task 4: Add Type-Level Tests (COMPLETED)

Added comprehensive type-level tests in `src/runtime/eval.test.ts`:
- Type tests for `evaluate()` with all primitive types (number, string, boolean, null, undefined)
- Type tests for `evaluate()` with parsed expressions from `parser.parse()`
- Type tests for `evaluate()` with nested expressions
- Type tests for `createEvaluator()` helper
- Edge case tests for parentheses, ternary, and manually constructed ASTs

All 714 tests pass including 98 tests in eval.test.ts.

## Task 5: Update Documentation (COMPLETED)

Updated the documentation to reflect the new type-safe evaluation feature:

### README.md Updates
- Added "Type-Safe Evaluation" section with comprehensive examples
- Added code examples showing type inference for number, boolean, and string result types
- Updated the "Evaluate Expressions" section to highlight type inference
- Updated "Key Features" section to emphasize type-safe evaluation

### docs/api-reference.md Updates
- Updated `evaluate()` section with new generic signature:
  ```typescript
  function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>>
  ```
- Added documentation of the type utilities (`ExtractOutputSchema`, `SchemaToType`)
- Added detailed "Type Inference Example" showing how types flow through
- Updated `createEvaluator()` section with new generic signature
- Added type inference example for `createEvaluator()`

### Key Documentation Points
- Return type is inferred from AST's `outputSchema` field
- `outputSchema: "number"` → returns `number`
- `outputSchema: "string"` → returns `string`
- `outputSchema: "boolean"` → returns `boolean`
- `outputSchema: "null"` → returns `null`
- `outputSchema: "undefined"` → returns `undefined`
- Unknown schemas → returns `unknown`

---

## Summary

The core type inference fix is complete. The `evaluate()` and `createEvaluator()` functions now correctly infer return types from the AST's `outputSchema` field. This means:

```typescript
const ast = parser.parse('1 + 2', {});
const value = evaluate(ast[0], ctx);
// TypeScript now knows: typeof value === number
```

The implementation uses TypeScript's conditional types to extract the `outputSchema` from the AST type parameter and map it to the corresponding TypeScript type using `SchemaToType`.

## Task 6: Connect Parse Schema to Eval Data (COMPLETED)

Implemented type-safe data validation in `evaluate()` and `createEvaluator()`. The evaluator now requires that data passed to it matches the types expected by the AST's identifier nodes.

### Implementation

Added new type utilities in `src/runtime/eval.ts`:

```typescript
// Extract all identifier nodes from an AST recursively
type ExtractIdentifiers<T> = T extends { node: 'identifier'; name: infer N; outputSchema: infer S }
  ? { name: N; outputSchema: S }
  : T extends object
    ? { [K in keyof T]: ExtractIdentifiers<T[K]> }[keyof T]
    : never;

// Convert identifier tuples to required data object type
type IdentifiersToData<T> = T extends {
  name: infer N extends string;
  outputSchema: infer S extends string;
}
  ? { [K in N]: SchemaToType<S> }
  : never;

// Merge union of single-key objects into intersection
type UnionToIntersection<U> = ...

// Extract required data types from AST
export type ExtractRequiredData<T> =
  ExtractIdentifiers<T> extends never
    ? Record<string, never>  // No identifiers - empty data OK
    : UnionToIntersection<IdentifiersToData<ExtractIdentifiers<T>>>;
```

Updated function signatures:

```typescript
// evaluate() now requires data to match AST's identifiers
export function evaluate<T, TData extends ExtractRequiredData<T>>(
  ast: T,
  ctx: EvalContext<TData>
): SchemaToType<ExtractOutputSchema<T>>

// createEvaluator() also enforces data constraints
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends ExtractRequiredData<T>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>>
}
```

### Type Safety Features

1. **Missing variables cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x is required but not provided
   evaluate(ast, { data: {}, nodes });
   ```

2. **Wrong data types cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x should be number, not string
   evaluate(ast, { data: { x: 'wrong' }, nodes });
   ```

3. **Extra properties are allowed:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // OK - extra 'y' is fine
   evaluate(ast, { data: { x: 42, y: 'extra' }, nodes });
   ```

4. **Empty data for literal-only expressions:**
   ```typescript
   const ast = { node: 'literal', value: 42, outputSchema: 'number' } as const;
   // OK - no identifiers means no data required
   evaluate(ast, { data: {}, nodes });
   ```

### Tests Added

Added 21 new tests in `src/runtime/eval.test.ts` under "evaluate - data-schema connection (Task 6)":

**Type-level tests with manually constructed ASTs:**
- requires correct data types for identifiers
- rejects missing variables in data (type error)
- rejects wrong data types (type error)
- allows extra properties in data
- accepts empty data for expressions without identifiers
- infers correct data types for string identifiers
- infers correct data types for boolean identifiers
- handles multiple identifiers with different types
- handles nested expressions with identifiers

**Runtime tests with parsed expressions:**
- evaluates parsed expression with identifiers
- evaluates parsed identifier expression
- throws for missing variable at runtime
- evaluates parsed string identifier
- evaluates parsed boolean identifier
- evaluates parsed comparison with identifier
- evaluates parsed nested expression with identifiers

**createEvaluator type-level tests:**
- requires correct data types for identifiers (manual AST)
- rejects missing variables (type error)
- rejects wrong data types (type error)
- evaluates parsed expression (runtime)

### Limitations

The type-level data validation works best with manually constructed ASTs that use `as const`. When using `parser.parse()`, the parsed AST type uses generic `string` for identifier `outputSchema` instead of literal values like `'number'`. This is a pre-existing limitation in the parser's type inference that would require fixing the parse-time type flow (related to Tasks 1-5 arktype integration).

Runtime validation (throwing errors for missing/wrong types) still works correctly because the runtime preserves the actual schema values.

### Files Modified

- `src/runtime/eval.ts`: Added type utilities and updated function signatures
- `src/runtime/eval.test.ts`: Added 21 new tests, updated 1 existing test

All 734 tests pass. No new lint errors.

## Task 7 (PRD): Study ArkType Integration (COMPLETED)

This corresponds to PRD Task 1. Investigated how arktype can be used for compile-time and runtime type validation.

### Key Findings

**1. How does arktype's generic validation work?**
- `type('number')` creates a Type object that validates at runtime
- The Type object has an `.infer` property for extracting the TypeScript type
- Invalid type strings cause compile-time errors via TypeScript's type system

**2. How to validate type strings at compile time?**
- Use `type.validate<T>` in generic function parameters
- Example: `function fn<const T>(schema: type.validate<T>) { ... }`
- This causes compile errors for invalid type strings like 'garbage'

**3. How does type.infer work?**
- After creating a Type: `const t = type('number')`
- Extract the TS type: `type T = typeof t.infer` // number
- Works with all valid arktype definitions

**4. What arktype types should Stringent support initially?**
- All primitives: 'number', 'string', 'boolean', 'null', 'undefined'
- Unions: 'string | number' (for ternary result types)
- Subtypes: 'string.email', 'number.integer' (validated at runtime)
- Constraints: 'number >= 0' (validated at runtime)

### Integration Pattern for Stringent

For `lhs()`, `rhs()`, `expr()` constraint validation:
```typescript
export const lhs = <const T extends string>(constraint?: type.validate<T>) => ...
```

For `parser.parse()` schema validation:
```typescript
parse<TSchema extends Record<string, string>>(
  input: string,
  schema: { [K in keyof TSchema]: type.validate<TSchema[K]> }
) => ...
```

For `SchemaToType` replacement:
- Use arktype's `type.infer` mechanism
- Direct type creation preserves inference: `type NumType = typeof type('number').infer`
- Generic functions with `type.validate` may lose return type inference due to TS limitations

### Tests Added

Created `src/arktype-research.test.ts` with 16 comprehensive tests:
- Question 1: How does arktype generic validation work? (6 tests)
- Question 2: How to validate type strings at compile time? (2 tests)
- Question 3: How does type.infer work? (2 tests)
- Question 4: What types should Stringent support initially? (3 tests)
- Integration pattern for Stringent (2 tests)
- Key findings summary (1 test)

All 750 tests pass. No lint errors.

## Task 8 (PRD Task 2): Create Type Validation Using ArkType (COMPLETED)

Replaced the hardcoded `SchemaToType` with arktype-based validation.

### Implementation

Updated `src/schema/index.ts` with new type utilities:

**1. `ValidArkType<T>` - Compile-Time Type Validation**
```typescript
export type ValidArkType<T extends string> = type.validate<T>;
```
Uses arktype's `type.validate` to validate type strings at compile time.
- Valid types return the type string itself
- Invalid types cause TypeScript compile errors

**2. `ArkTypeSchemaToType<T>` - Direct arktype Inference**
```typescript
export type ArkTypeSchemaToType<T extends string> = type.infer<T>;
```
Direct wrapper around arktype's `type.infer` (no fallback).
- Returns the TypeScript type for valid arktype strings
- Returns `never` for invalid type strings

**3. `SchemaToType<T>` - Backwards-Compatible Inference**
```typescript
export type SchemaToType<T extends string> =
  // Fast path for common primitives
  T extends 'number' ? number
  : T extends 'string' ? string
  : T extends 'boolean' ? boolean
  : T extends 'null' ? null
  : T extends 'undefined' ? undefined
  : T extends 'unknown' ? unknown
  : // Only use arktype for literal strings (not generic 'string')
    string extends T ? unknown
  : SchemaToTypeAdvanced<T>;
```
- Fast path for common primitives to avoid deep type instantiation
- Detects advanced arktype patterns (subtypes, constraints, unions, arrays)
- Falls back to `unknown` for invalid/generic types

### Type Inference Results

The updated `SchemaToType` now correctly infers:
- `'number'` → `number`
- `'string'` → `string`
- `'boolean'` → `boolean`
- `'null'` → `null`
- `'undefined'` → `undefined`
- `'unknown'` → `unknown`
- `'string.email'` → `string` (subtype)
- `'number.integer'` → `number` (subtype)
- `'number >= 0'` → `number` (constraint)
- `'string | number'` → `string | number` (union)
- `'string[]'` → `string[]` (array)
- `'garbage'` → `unknown` (invalid, fallback)

### Tests Added

Created `src/schema/arktype-integration.test.ts` with 32 comprehensive tests:
- SchemaToType - Primitive Types (5 tests)
- SchemaToType - ArkType Subtypes (4 tests)
- SchemaToType - ArkType Constraints (4 tests)
- SchemaToType - Union Types (4 tests)
- ArkTypeSchemaToType - Direct arktype.infer (5 tests)
- ValidArkType - Compile-Time Validation (4 tests)
- SchemaToType - Edge Cases (3 tests)
- SchemaToType - Fallback Behavior (3 tests)

### Known Limitations

1. **Type widening in complex parsers**: When using `parser.parse()` with many nodes,
   the outputSchema type can get widened from literal `"string"` to generic `string`.
   This is a pre-existing limitation (PRD GAP 6) and is documented in the test.

2. **Requires literal type strings**: The arktype inference only works with literal
   string types. Generic `string` types fall back to `unknown` to prevent infinite
   type recursion.

### Files Modified

- `src/schema/index.ts`: Added arktype import, `ValidArkType`, `ArkTypeSchemaToType`,
  updated `SchemaToType`, added `SchemaToTypeAdvanced` and `ArkTypeSchemaToTypeSafe` helpers
- `src/schema/arktype-integration.test.ts`: New test file with 32 tests
- `src/runtime/eval.test.ts`: Updated 1 test to reflect actual type inference behavior

All 783 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 9 (PRD Task 3): Fix Schema Validation in ExprSchema Factories (COMPLETED)

Updated `lhs()`, `rhs()`, `expr()` to validate constraints at compile time using arktype.

### Implementation

Updated `src/schema/index.ts`:

**1. Changed arktype import from type-only to value import:**
```typescript
// Before
import type { type } from 'arktype';

// After
import { type } from 'arktype';
```

**2. Updated function signatures to use `type.validate`:**
```typescript
// Before
export const lhs = <const TConstraint extends string>(constraint?: TConstraint) => ...
export const rhs = <const TConstraint extends string>(constraint?: TConstraint) => ...
export const expr = <const TConstraint extends string>(constraint?: TConstraint) => ...

// After
export const lhs = <const TConstraint extends string>(constraint?: type.validate<TConstraint>) => ...
export const rhs = <const TConstraint extends string>(constraint?: type.validate<TConstraint>) => ...
export const expr = <const TConstraint extends string>(constraint?: type.validate<TConstraint>) => ...
```

### Validation Behavior

**Valid constraints (no type error):**
- Primitives: `'number'`, `'string'`, `'boolean'`, `'null'`, `'undefined'`
- Subtypes: `'string.email'`, `'number.integer'`, `'string.uuid'`
- Constraints: `'number >= 0'`, `'number > 0'`, `'1 <= number <= 100'`
- Unions: `'string | number'`, `'string | number | boolean'`
- Arrays: `'string[]'`, `'number[][]'`
- Other types: `'Date'`, `'bigint'`, `'symbol'`

**Invalid constraints (TypeScript compile error):**
- `lhs('garbage')` - Error: `Argument of type '"garbage"' is not assignable to parameter of type '"'garbage' is unresolvable"'`
- `rhs('asdfghjkl')` - Same type of error
- `expr('notAType')` - Same type of error

### Tests Added

Created `src/schema/constraint-validation.test.ts` with 34 tests:

**lhs() constraint validation (10 tests):**
- accepts valid primitive constraints
- accepts valid arktype subtypes
- accepts valid arktype constraints
- accepts valid union types
- accepts no constraint (unconstrained expression)
- rejects invalid constraint strings (type error)
- preserves constraint type in schema
- works with .as() for named bindings

**rhs() constraint validation (9 tests):**
- Same categories as lhs()

**expr() constraint validation (9 tests):**
- Same categories as lhs()

**defineNode() integration (4 tests):**
- works with validated lhs/rhs constraints in patterns
- works with arktype subtypes in patterns
- works with arktype constraints in patterns
- works with union types in patterns
- rejects invalid constraints in defineNode (type error)

**Edge cases (5 tests):**
- handles array types
- handles complex union types
- handles Date type
- handles bigint type
- handles symbol type

### Files Modified

- `src/schema/index.ts`: Changed arktype import and updated `lhs()`, `rhs()`, `expr()` signatures
- `src/schema/constraint-validation.test.ts`: New test file with 34 tests

All 816 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 10 (PRD Task 4): Fix Schema Validation in defineNode (COMPLETED)

Updated `defineNode()` to validate `resultType` at compile time using arktype.

### Implementation

Updated `src/schema/index.ts`:

**Changed the resultType parameter to use `type.validate`:**
```typescript
// Before
export function defineNode<
  const TName extends string,
  const TPattern extends readonly PatternSchema[],
  const TPrecedence extends Precedence,
  const TResultType extends string,
>(config: {
  // ...
  readonly resultType: TResultType;  // No validation
  // ...
})

// After
export function defineNode<
  const TName extends string,
  const TPattern extends readonly PatternSchema[],
  const TPrecedence extends Precedence,
  const TResultType extends string,
>(config: {
  // ...
  readonly resultType: type.validate<TResultType>;  // Validates at compile time
  // ...
})
```

### Validation Behavior

**Valid resultType values (no type error):**
- Primitives: `'number'`, `'string'`, `'boolean'`, `'null'`, `'undefined'`
- Subtypes: `'string.email'`, `'number.integer'`
- Constraints: `'number >= 0'`, `'1 <= number <= 100'`
- Unions: `'string | number'`, `'string | number | boolean'`
- Arrays: `'string[]'`
- Special: `'unknown'` (for computed types like parentheses)

**Invalid resultType values (TypeScript compile error):**
- `resultType: 'garbage'` - Error: `Type '"garbage"' is not assignable to type '"'garbage' is unresolvable"'`
- `resultType: 'asdfghjkl'` - Same type of error
- `resultType: 'nubmer'` - Same type of error (misspelled)

### Tests Added

Added 10 tests in `src/schema/constraint-validation.test.ts` under "defineNode() resultType validation (Task 4)":

1. accepts valid primitive resultType
2. accepts valid arktype subtype resultType
3. accepts valid arktype constraint resultType
4. accepts valid union resultType
5. accepts array resultType
6. accepts unknown resultType for computed types
7. rejects invalid resultType (type error)
8. rejects another invalid resultType (type error)
9. rejects invalid misspelled resultType (type error)
10. preserves resultType type in NodeSchema

### Files Modified

- `src/schema/index.ts`: Updated `defineNode()` to use `type.validate<TResultType>` for resultType parameter, updated JSDoc
- `src/schema/constraint-validation.test.ts`: Added 10 tests for resultType validation

All 826 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 11 (PRD Task 5): Fix Schema Validation in parser.parse() (COMPLETED)

Updated `parser.parse()` to validate schema types at compile time using arktype.

### Implementation

Updated `src/createParser.ts`:

**1. Added `ValidatedSchema` type:**
```typescript
type ValidatedSchema<TSchema extends Record<string, string>> = {
  [K in keyof TSchema]: string extends TSchema[K]
    ? string // Skip validation for generic string values
    : type.validate<TSchema[K]>; // Validate literal string values
};
```

**2. Updated Parser interface:**
```typescript
parse<TInput extends string, TSchema extends Record<string, string>>(
  input: ValidatedInput<TGrammar, TInput, Context<TSchema>>,
  schema: ValidatedSchema<TSchema>
): Parse<TGrammar, TInput, Context<TSchema>>;
```

**3. Updated createParser implementation:**
```typescript
parse<TInput extends string, TSchema extends Record<string, string>>(
  input: TInput,
  schema: ValidatedSchema<TSchema>
): Parse<ComputeGrammar<TNodes>, TInput, Context<TSchema>> { ... }
```

### Validation Behavior

**Valid schema types (no type error):**
- Primitives: `'number'`, `'string'`, `'boolean'`, `'null'`, `'undefined'`
- Subtypes: `'string.email'`, `'number.integer'`, `'string.uuid'`, `'string.url'`
- Constraints: `'number >= 0'`, `'number > 0'`, `'1 <= number <= 100'`, `'string >= 8'`
- Unions: `'string | number'`, `'string | number | boolean'`, `'null | string'`
- Arrays: `'string[]'`, `'number[]'`
- Other types: `'Date'`, `'bigint'`, `'symbol'`, `'unknown'`

**Invalid schema types (TypeScript compile error):**
- `parser.parse('x', { x: 'garbage' })` - Error: `Type '"garbage"' is not assignable to type '"'garbage' is unresolvable"'`
- `parser.parse('x', { x: 'asdfghjkl' })` - Same type of error
- `parser.parse('x', { x: 'nubmer' })` - Same type of error (misspelled)
- `parser.parse('x', { x: 'string.invalid' })` - Same type of error (invalid subtype)

### Key Design Decisions

1. **Generic string handling:** When schema values are generic `string` type (not literal strings), validation is skipped to avoid deep type instantiation issues with arktype's `type.validate`.

2. **Mapped type validation:** Uses a mapped type that transforms each schema value through `type.validate<T>` for literal types.

3. **Runtime cast:** The implementation casts `schema as TSchema` to maintain the original type for downstream usage while the parameter type enforces validation.

### Tests Added

Created `src/createParser.schema-validation.test.ts` with 34 tests:

**Valid types (24 tests):**
- accepts primitive type strings (5 tests)
- accepts arktype subtypes (4 tests)
- accepts arktype constraints (4 tests)
- accepts union types (3 tests)
- accepts array types (2 tests)
- accepts other valid types (4 tests)
- accepts empty schema (1 test)
- accepts multiple schema entries (1 test)

**Invalid types - type errors (8 tests):**
- rejects garbage type string
- rejects asdfghjkl type string
- rejects misspelled number
- rejects misspelled string
- rejects invalid subtype
- rejects invalid constraint syntax
- rejects random text
- rejects partially invalid schema

**Type preservation tests (2 tests):**
- preserves literal schema types
- works with as const assertions

### Bug Fix

Fixed pre-existing bug in `src/schema/constraint-validation.test.ts:462` where `precedence: 'atom'` was used instead of a number (Precedence type is `number`).

### Files Modified

- `src/createParser.ts`: Added arktype import, `ValidatedSchema` type, updated `Parser.parse()` and `createParser()` implementation
- `src/createParser.schema-validation.test.ts`: New test file with 34 tests
- `src/schema/constraint-validation.test.ts`: Fixed bug (changed `precedence: 'atom'` to `precedence: 0`)

All 860 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).

## Task 12 (PRD Task 6 completion): Add Runtime ArkType Validation (COMPLETED)

Completed the deferred item from Task 6: "Add runtime validation using arktype".

### Implementation

Updated `src/runtime/eval.ts`:

**1. Added arktype import:**
```typescript
import { type, Type } from 'arktype';
```

**2. Added validator caching for performance:**
```typescript
const validatorCache = new Map<string, Type>();

function getValidator(schema: string): Type {
  let validator = validatorCache.get(schema);
  if (!validator) {
    validator = type(schema as never) as Type;
    validatorCache.set(schema, validator);
  }
  return validator;
}
```

**3. Added validation function:**
```typescript
function validateValue(value: unknown, schema: string, variableName: string): void {
  if (schema === 'unknown' || schema === 'never') {
    return; // Skip validation for generic schemas
  }

  const validator = getValidator(schema);
  const result = validator(value);

  if (result instanceof type.errors) {
    throw new Error(
      `Variable '${variableName}' failed validation for schema '${schema}': ${result.summary}`
    );
  }
}
```

**4. Integrated validation into identifier evaluation:**
```typescript
// Handle identifier nodes - look up value in context and validate against schema
if (nodeType === 'identifier') {
  // ... existing code to get name and value ...

  // Validate value against arktype schema at runtime
  if ('outputSchema' in node && typeof node.outputSchema === 'string') {
    validateValue(value, node.outputSchema, name);
  }

  return value as ReturnType;
}
```

### Runtime Validation Behavior

**Now the evaluator validates identifier values against their arktype schemas:**

- `'number >= 0'` - Throws if value is negative
- `'number > 0'` - Throws if value is zero or negative
- `'number.integer'` - Throws if value is not an integer
- `'1 <= number <= 100'` - Throws if value is out of range
- `'string.email'` - Throws if value is not a valid email
- `'string.uuid'` - Throws if value is not a valid UUID
- `'string >= 8'` - Throws if string length is less than 8
- `'string | number'` - Throws if value is neither string nor number
- Basic type constraints - Throws if value doesn't match type

### Tests Added

Added 27 new tests in `src/runtime/eval.test.ts` under "evaluate - runtime arktype constraint validation":

**Number constraints (7 tests):**
- validates number >= 0 constraint - accepts valid value
- validates number >= 0 constraint - accepts zero
- validates number >= 0 constraint - rejects negative value
- validates number > 0 constraint - rejects zero
- validates number.integer constraint - rejects float
- validates number.integer constraint - accepts integer
- validates range constraint 1 <= number <= 100

**String constraints (6 tests):**
- validates string.email constraint - accepts valid email
- validates string.email constraint - rejects invalid email
- validates string.uuid constraint - accepts valid uuid
- validates string.uuid constraint - rejects invalid uuid
- validates string length constraint - rejects too short
- validates string length constraint - accepts valid length

**Basic type constraints (5 tests):**
- validates number type - rejects string
- validates string type - rejects number
- validates boolean type - rejects string
- validates null type - rejects undefined
- validates undefined type - rejects null

**Union type constraints (3 tests):**
- validates string | number union - accepts string
- validates string | number union - accepts number
- validates string | number union - rejects boolean

**Parsed expressions with constraints (3 tests):**
- validates parsed identifier with number >= 0 constraint
- validates parsed identifier with string.email constraint
- validates parsed expression with two constrained identifiers

**createEvaluator with constraints (1 test):**
- validates constraint in createEvaluator

**Edge cases (2 tests):**
- skips validation for unknown schema
- validates nested identifier in expression

### Existing Test Updates

Updated 2 existing tests that now throw runtime errors in addition to type errors:
- "rejects wrong data types (type error)" → "rejects wrong data types (type error and runtime error)"
- Updated both in evaluate() and createEvaluator() sections

### Files Modified

- `src/runtime/eval.ts`: Added arktype import, validator cache, validateValue function, integrated validation into identifier handling
- `src/runtime/eval.test.ts`: Added 27 new tests, updated 2 existing tests

All 887 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).
