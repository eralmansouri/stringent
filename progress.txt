# Stringent v2 - Type Inference Fix Progress

## Task 1: Understanding the Codebase (COMPLETED)

### What is the `outputSchema` field on AST nodes? Where does it come from?

The `outputSchema` field is defined in `src/primitive/index.ts:31-34`:
```typescript
export interface ASTNode<TType extends string = string, TOutputSchema = unknown> {
  node: TType;
  outputSchema: TOutputSchema;
}
```

It represents the string type of the result (e.g., "number", "string", "boolean"). It comes from:
1. **Literal nodes**: Set by runtime parsers (e.g., `outputSchema: 'number'` for number literals)
2. **Identifier nodes**: Set from context data type (e.g., `ctx.data[name]`)
3. **Operator nodes**: Set from `nodeSchema.resultType` during `buildNodeResult()`

### How does `parser.parse()` preserve type information from input to output?

The parser uses a dual-track architecture:
1. **Compile-time**: The `Parse<TGrammar, TInput, Context>` type computes exact result types by tokenizing input and building typed AST nodes
2. **Runtime**: The runtime parser mirrors this structure, setting `outputSchema` fields correctly

The `createParser()` function casts runtime results to match compile-time types.

### What existing type utilities does the codebase have for mapping schema strings to TypeScript types?

In `src/schema/index.ts`:
- `SchemaToType<T>`: Maps "number" → number, "string" → string, etc.
- `InferNodeType<TSchema>`: Maps schema to AST node type
- `InferEvaluatedType<TSchema>`: Maps schema to runtime value type
- `InferBindings<TPattern>`: Extracts AST node types from pattern
- `InferEvaluatedBindings<TPattern>`: Extracts evaluated value types from pattern

### Why does the current `evaluate()` function lose type information?

The original function signature was:
```typescript
export function evaluate(ast: unknown, ctx: EvalContext): unknown
```

- Input type is `unknown` - TypeScript can't see the `outputSchema` field
- No type parameter captures the AST type
- Return type is hardcoded to `unknown`

## Task 2: Fix `evaluate()` Return Type (COMPLETED)

Fixed in `src/runtime/eval.ts`:
```typescript
type ExtractOutputSchema<T> = T extends { outputSchema: infer S extends string } ? S : 'unknown';

export function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>> {
  // Implementation unchanged, just casts to the inferred return type
}
```

Now when you call `evaluate()` with an AST that has `outputSchema: "number"`, the return type is `number`.

## Task 3: Fix `createEvaluator()` Return Type (COMPLETED)

Updated in `src/runtime/eval.ts`:
```typescript
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends Record<string, unknown>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>> {
    return evaluate(ast, { data, nodes });
  };
}
```

## Task 4: Add Type-Level Tests (COMPLETED)

Added comprehensive type-level tests in `src/runtime/eval.test.ts`:
- Type tests for `evaluate()` with all primitive types (number, string, boolean, null, undefined)
- Type tests for `evaluate()` with parsed expressions from `parser.parse()`
- Type tests for `evaluate()` with nested expressions
- Type tests for `createEvaluator()` helper
- Edge case tests for parentheses, ternary, and manually constructed ASTs

All 714 tests pass including 98 tests in eval.test.ts.

## Task 5: Update Documentation (COMPLETED)

Updated the documentation to reflect the new type-safe evaluation feature:

### README.md Updates
- Added "Type-Safe Evaluation" section with comprehensive examples
- Added code examples showing type inference for number, boolean, and string result types
- Updated the "Evaluate Expressions" section to highlight type inference
- Updated "Key Features" section to emphasize type-safe evaluation

### docs/api-reference.md Updates
- Updated `evaluate()` section with new generic signature:
  ```typescript
  function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>>
  ```
- Added documentation of the type utilities (`ExtractOutputSchema`, `SchemaToType`)
- Added detailed "Type Inference Example" showing how types flow through
- Updated `createEvaluator()` section with new generic signature
- Added type inference example for `createEvaluator()`

### Key Documentation Points
- Return type is inferred from AST's `outputSchema` field
- `outputSchema: "number"` → returns `number`
- `outputSchema: "string"` → returns `string`
- `outputSchema: "boolean"` → returns `boolean`
- `outputSchema: "null"` → returns `null`
- `outputSchema: "undefined"` → returns `undefined`
- Unknown schemas → returns `unknown`

---

## Summary

The core type inference fix is complete. The `evaluate()` and `createEvaluator()` functions now correctly infer return types from the AST's `outputSchema` field. This means:

```typescript
const ast = parser.parse('1 + 2', {});
const value = evaluate(ast[0], ctx);
// TypeScript now knows: typeof value === number
```

The implementation uses TypeScript's conditional types to extract the `outputSchema` from the AST type parameter and map it to the corresponding TypeScript type using `SchemaToType`.

## Task 6: Connect Parse Schema to Eval Data (COMPLETED)

Implemented type-safe data validation in `evaluate()` and `createEvaluator()`. The evaluator now requires that data passed to it matches the types expected by the AST's identifier nodes.

### Implementation

Added new type utilities in `src/runtime/eval.ts`:

```typescript
// Extract all identifier nodes from an AST recursively
type ExtractIdentifiers<T> = T extends { node: 'identifier'; name: infer N; outputSchema: infer S }
  ? { name: N; outputSchema: S }
  : T extends object
    ? { [K in keyof T]: ExtractIdentifiers<T[K]> }[keyof T]
    : never;

// Convert identifier tuples to required data object type
type IdentifiersToData<T> = T extends {
  name: infer N extends string;
  outputSchema: infer S extends string;
}
  ? { [K in N]: SchemaToType<S> }
  : never;

// Merge union of single-key objects into intersection
type UnionToIntersection<U> = ...

// Extract required data types from AST
export type ExtractRequiredData<T> =
  ExtractIdentifiers<T> extends never
    ? Record<string, never>  // No identifiers - empty data OK
    : UnionToIntersection<IdentifiersToData<ExtractIdentifiers<T>>>;
```

Updated function signatures:

```typescript
// evaluate() now requires data to match AST's identifiers
export function evaluate<T, TData extends ExtractRequiredData<T>>(
  ast: T,
  ctx: EvalContext<TData>
): SchemaToType<ExtractOutputSchema<T>>

// createEvaluator() also enforces data constraints
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends ExtractRequiredData<T>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>>
}
```

### Type Safety Features

1. **Missing variables cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x is required but not provided
   evaluate(ast, { data: {}, nodes });
   ```

2. **Wrong data types cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x should be number, not string
   evaluate(ast, { data: { x: 'wrong' }, nodes });
   ```

3. **Extra properties are allowed:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // OK - extra 'y' is fine
   evaluate(ast, { data: { x: 42, y: 'extra' }, nodes });
   ```

4. **Empty data for literal-only expressions:**
   ```typescript
   const ast = { node: 'literal', value: 42, outputSchema: 'number' } as const;
   // OK - no identifiers means no data required
   evaluate(ast, { data: {}, nodes });
   ```

### Tests Added

Added 21 new tests in `src/runtime/eval.test.ts` under "evaluate - data-schema connection (Task 6)":

**Type-level tests with manually constructed ASTs:**
- requires correct data types for identifiers
- rejects missing variables in data (type error)
- rejects wrong data types (type error)
- allows extra properties in data
- accepts empty data for expressions without identifiers
- infers correct data types for string identifiers
- infers correct data types for boolean identifiers
- handles multiple identifiers with different types
- handles nested expressions with identifiers

**Runtime tests with parsed expressions:**
- evaluates parsed expression with identifiers
- evaluates parsed identifier expression
- throws for missing variable at runtime
- evaluates parsed string identifier
- evaluates parsed boolean identifier
- evaluates parsed comparison with identifier
- evaluates parsed nested expression with identifiers

**createEvaluator type-level tests:**
- requires correct data types for identifiers (manual AST)
- rejects missing variables (type error)
- rejects wrong data types (type error)
- evaluates parsed expression (runtime)

### Limitations

The type-level data validation works best with manually constructed ASTs that use `as const`. When using `parser.parse()`, the parsed AST type uses generic `string` for identifier `outputSchema` instead of literal values like `'number'`. This is a pre-existing limitation in the parser's type inference that would require fixing the parse-time type flow (related to Tasks 1-5 arktype integration).

Runtime validation (throwing errors for missing/wrong types) still works correctly because the runtime preserves the actual schema values.

### Files Modified

- `src/runtime/eval.ts`: Added type utilities and updated function signatures
- `src/runtime/eval.test.ts`: Added 21 new tests, updated 1 existing test

All 734 tests pass. No new lint errors.
