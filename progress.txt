# Stringent v2 - Type Inference Fix Progress

## Task 1: Understanding the Codebase (COMPLETED)

### What is the `outputSchema` field on AST nodes? Where does it come from?

The `outputSchema` field is defined in `src/primitive/index.ts:31-34`:
```typescript
export interface ASTNode<TType extends string = string, TOutputSchema = unknown> {
  node: TType;
  outputSchema: TOutputSchema;
}
```

It represents the string type of the result (e.g., "number", "string", "boolean"). It comes from:
1. **Literal nodes**: Set by runtime parsers (e.g., `outputSchema: 'number'` for number literals)
2. **Identifier nodes**: Set from context data type (e.g., `ctx.data[name]`)
3. **Operator nodes**: Set from `nodeSchema.resultType` during `buildNodeResult()`

### How does `parser.parse()` preserve type information from input to output?

The parser uses a dual-track architecture:
1. **Compile-time**: The `Parse<TGrammar, TInput, Context>` type computes exact result types by tokenizing input and building typed AST nodes
2. **Runtime**: The runtime parser mirrors this structure, setting `outputSchema` fields correctly

The `createParser()` function casts runtime results to match compile-time types.

### What existing type utilities does the codebase have for mapping schema strings to TypeScript types?

In `src/schema/index.ts`:
- `SchemaToType<T>`: Maps "number" → number, "string" → string, etc.
- `InferNodeType<TSchema>`: Maps schema to AST node type
- `InferEvaluatedType<TSchema>`: Maps schema to runtime value type
- `InferBindings<TPattern>`: Extracts AST node types from pattern
- `InferEvaluatedBindings<TPattern>`: Extracts evaluated value types from pattern

### Why does the current `evaluate()` function lose type information?

The original function signature was:
```typescript
export function evaluate(ast: unknown, ctx: EvalContext): unknown
```

- Input type is `unknown` - TypeScript can't see the `outputSchema` field
- No type parameter captures the AST type
- Return type is hardcoded to `unknown`

## Task 2: Fix `evaluate()` Return Type (COMPLETED)

Fixed in `src/runtime/eval.ts`:
```typescript
type ExtractOutputSchema<T> = T extends { outputSchema: infer S extends string } ? S : 'unknown';

export function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>> {
  // Implementation unchanged, just casts to the inferred return type
}
```

Now when you call `evaluate()` with an AST that has `outputSchema: "number"`, the return type is `number`.

## Task 3: Fix `createEvaluator()` Return Type (COMPLETED)

Updated in `src/runtime/eval.ts`:
```typescript
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends Record<string, unknown>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>> {
    return evaluate(ast, { data, nodes });
  };
}
```

## Task 4: Add Type-Level Tests (COMPLETED)

Added comprehensive type-level tests in `src/runtime/eval.test.ts`:
- Type tests for `evaluate()` with all primitive types (number, string, boolean, null, undefined)
- Type tests for `evaluate()` with parsed expressions from `parser.parse()`
- Type tests for `evaluate()` with nested expressions
- Type tests for `createEvaluator()` helper
- Edge case tests for parentheses, ternary, and manually constructed ASTs

All 714 tests pass including 98 tests in eval.test.ts.

## Task 5: Update Documentation (COMPLETED)

Updated the documentation to reflect the new type-safe evaluation feature:

### README.md Updates
- Added "Type-Safe Evaluation" section with comprehensive examples
- Added code examples showing type inference for number, boolean, and string result types
- Updated the "Evaluate Expressions" section to highlight type inference
- Updated "Key Features" section to emphasize type-safe evaluation

### docs/api-reference.md Updates
- Updated `evaluate()` section with new generic signature:
  ```typescript
  function evaluate<T>(ast: T, ctx: EvalContext): SchemaToType<ExtractOutputSchema<T>>
  ```
- Added documentation of the type utilities (`ExtractOutputSchema`, `SchemaToType`)
- Added detailed "Type Inference Example" showing how types flow through
- Updated `createEvaluator()` section with new generic signature
- Added type inference example for `createEvaluator()`

### Key Documentation Points
- Return type is inferred from AST's `outputSchema` field
- `outputSchema: "number"` → returns `number`
- `outputSchema: "string"` → returns `string`
- `outputSchema: "boolean"` → returns `boolean`
- `outputSchema: "null"` → returns `null`
- `outputSchema: "undefined"` → returns `undefined`
- Unknown schemas → returns `unknown`

---

## Summary

The core type inference fix is complete. The `evaluate()` and `createEvaluator()` functions now correctly infer return types from the AST's `outputSchema` field. This means:

```typescript
const ast = parser.parse('1 + 2', {});
const value = evaluate(ast[0], ctx);
// TypeScript now knows: typeof value === number
```

The implementation uses TypeScript's conditional types to extract the `outputSchema` from the AST type parameter and map it to the corresponding TypeScript type using `SchemaToType`.

## Task 6: Connect Parse Schema to Eval Data (COMPLETED)

Implemented type-safe data validation in `evaluate()` and `createEvaluator()`. The evaluator now requires that data passed to it matches the types expected by the AST's identifier nodes.

### Implementation

Added new type utilities in `src/runtime/eval.ts`:

```typescript
// Extract all identifier nodes from an AST recursively
type ExtractIdentifiers<T> = T extends { node: 'identifier'; name: infer N; outputSchema: infer S }
  ? { name: N; outputSchema: S }
  : T extends object
    ? { [K in keyof T]: ExtractIdentifiers<T[K]> }[keyof T]
    : never;

// Convert identifier tuples to required data object type
type IdentifiersToData<T> = T extends {
  name: infer N extends string;
  outputSchema: infer S extends string;
}
  ? { [K in N]: SchemaToType<S> }
  : never;

// Merge union of single-key objects into intersection
type UnionToIntersection<U> = ...

// Extract required data types from AST
export type ExtractRequiredData<T> =
  ExtractIdentifiers<T> extends never
    ? Record<string, never>  // No identifiers - empty data OK
    : UnionToIntersection<IdentifiersToData<ExtractIdentifiers<T>>>;
```

Updated function signatures:

```typescript
// evaluate() now requires data to match AST's identifiers
export function evaluate<T, TData extends ExtractRequiredData<T>>(
  ast: T,
  ctx: EvalContext<TData>
): SchemaToType<ExtractOutputSchema<T>>

// createEvaluator() also enforces data constraints
export function createEvaluator(nodes: readonly NodeSchema[]) {
  return function evaluator<T, TData extends ExtractRequiredData<T>>(
    ast: T,
    data: TData
  ): SchemaToType<ExtractOutputSchema<T>>
}
```

### Type Safety Features

1. **Missing variables cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x is required but not provided
   evaluate(ast, { data: {}, nodes });
   ```

2. **Wrong data types cause type errors:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // @ts-expect-error - x should be number, not string
   evaluate(ast, { data: { x: 'wrong' }, nodes });
   ```

3. **Extra properties are allowed:**
   ```typescript
   const ast = { node: 'identifier', name: 'x', outputSchema: 'number' } as const;
   // OK - extra 'y' is fine
   evaluate(ast, { data: { x: 42, y: 'extra' }, nodes });
   ```

4. **Empty data for literal-only expressions:**
   ```typescript
   const ast = { node: 'literal', value: 42, outputSchema: 'number' } as const;
   // OK - no identifiers means no data required
   evaluate(ast, { data: {}, nodes });
   ```

### Tests Added

Added 21 new tests in `src/runtime/eval.test.ts` under "evaluate - data-schema connection (Task 6)":

**Type-level tests with manually constructed ASTs:**
- requires correct data types for identifiers
- rejects missing variables in data (type error)
- rejects wrong data types (type error)
- allows extra properties in data
- accepts empty data for expressions without identifiers
- infers correct data types for string identifiers
- infers correct data types for boolean identifiers
- handles multiple identifiers with different types
- handles nested expressions with identifiers

**Runtime tests with parsed expressions:**
- evaluates parsed expression with identifiers
- evaluates parsed identifier expression
- throws for missing variable at runtime
- evaluates parsed string identifier
- evaluates parsed boolean identifier
- evaluates parsed comparison with identifier
- evaluates parsed nested expression with identifiers

**createEvaluator type-level tests:**
- requires correct data types for identifiers (manual AST)
- rejects missing variables (type error)
- rejects wrong data types (type error)
- evaluates parsed expression (runtime)

### Limitations

The type-level data validation works best with manually constructed ASTs that use `as const`. When using `parser.parse()`, the parsed AST type uses generic `string` for identifier `outputSchema` instead of literal values like `'number'`. This is a pre-existing limitation in the parser's type inference that would require fixing the parse-time type flow (related to Tasks 1-5 arktype integration).

Runtime validation (throwing errors for missing/wrong types) still works correctly because the runtime preserves the actual schema values.

### Files Modified

- `src/runtime/eval.ts`: Added type utilities and updated function signatures
- `src/runtime/eval.test.ts`: Added 21 new tests, updated 1 existing test

All 734 tests pass. No new lint errors.

## Task 7 (PRD): Study ArkType Integration (COMPLETED)

This corresponds to PRD Task 1. Investigated how arktype can be used for compile-time and runtime type validation.

### Key Findings

**1. How does arktype's generic validation work?**
- `type('number')` creates a Type object that validates at runtime
- The Type object has an `.infer` property for extracting the TypeScript type
- Invalid type strings cause compile-time errors via TypeScript's type system

**2. How to validate type strings at compile time?**
- Use `type.validate<T>` in generic function parameters
- Example: `function fn<const T>(schema: type.validate<T>) { ... }`
- This causes compile errors for invalid type strings like 'garbage'

**3. How does type.infer work?**
- After creating a Type: `const t = type('number')`
- Extract the TS type: `type T = typeof t.infer` // number
- Works with all valid arktype definitions

**4. What arktype types should Stringent support initially?**
- All primitives: 'number', 'string', 'boolean', 'null', 'undefined'
- Unions: 'string | number' (for ternary result types)
- Subtypes: 'string.email', 'number.integer' (validated at runtime)
- Constraints: 'number >= 0' (validated at runtime)

### Integration Pattern for Stringent

For `lhs()`, `rhs()`, `expr()` constraint validation:
```typescript
export const lhs = <const T extends string>(constraint?: type.validate<T>) => ...
```

For `parser.parse()` schema validation:
```typescript
parse<TSchema extends Record<string, string>>(
  input: string,
  schema: { [K in keyof TSchema]: type.validate<TSchema[K]> }
) => ...
```

For `SchemaToType` replacement:
- Use arktype's `type.infer` mechanism
- Direct type creation preserves inference: `type NumType = typeof type('number').infer`
- Generic functions with `type.validate` may lose return type inference due to TS limitations

### Tests Added

Created `src/arktype-research.test.ts` with 16 comprehensive tests:
- Question 1: How does arktype generic validation work? (6 tests)
- Question 2: How to validate type strings at compile time? (2 tests)
- Question 3: How does type.infer work? (2 tests)
- Question 4: What types should Stringent support initially? (3 tests)
- Integration pattern for Stringent (2 tests)
- Key findings summary (1 test)

All 750 tests pass. No lint errors.

## Task 8 (PRD Task 2): Create Type Validation Using ArkType (COMPLETED)

Replaced the hardcoded `SchemaToType` with arktype-based validation.

### Implementation

Updated `src/schema/index.ts` with new type utilities:

**1. `ValidArkType<T>` - Compile-Time Type Validation**
```typescript
export type ValidArkType<T extends string> = type.validate<T>;
```
Uses arktype's `type.validate` to validate type strings at compile time.
- Valid types return the type string itself
- Invalid types cause TypeScript compile errors

**2. `ArkTypeSchemaToType<T>` - Direct arktype Inference**
```typescript
export type ArkTypeSchemaToType<T extends string> = type.infer<T>;
```
Direct wrapper around arktype's `type.infer` (no fallback).
- Returns the TypeScript type for valid arktype strings
- Returns `never` for invalid type strings

**3. `SchemaToType<T>` - Backwards-Compatible Inference**
```typescript
export type SchemaToType<T extends string> =
  // Fast path for common primitives
  T extends 'number' ? number
  : T extends 'string' ? string
  : T extends 'boolean' ? boolean
  : T extends 'null' ? null
  : T extends 'undefined' ? undefined
  : T extends 'unknown' ? unknown
  : // Only use arktype for literal strings (not generic 'string')
    string extends T ? unknown
  : SchemaToTypeAdvanced<T>;
```
- Fast path for common primitives to avoid deep type instantiation
- Detects advanced arktype patterns (subtypes, constraints, unions, arrays)
- Falls back to `unknown` for invalid/generic types

### Type Inference Results

The updated `SchemaToType` now correctly infers:
- `'number'` → `number`
- `'string'` → `string`
- `'boolean'` → `boolean`
- `'null'` → `null`
- `'undefined'` → `undefined`
- `'unknown'` → `unknown`
- `'string.email'` → `string` (subtype)
- `'number.integer'` → `number` (subtype)
- `'number >= 0'` → `number` (constraint)
- `'string | number'` → `string | number` (union)
- `'string[]'` → `string[]` (array)
- `'garbage'` → `unknown` (invalid, fallback)

### Tests Added

Created `src/schema/arktype-integration.test.ts` with 32 comprehensive tests:
- SchemaToType - Primitive Types (5 tests)
- SchemaToType - ArkType Subtypes (4 tests)
- SchemaToType - ArkType Constraints (4 tests)
- SchemaToType - Union Types (4 tests)
- ArkTypeSchemaToType - Direct arktype.infer (5 tests)
- ValidArkType - Compile-Time Validation (4 tests)
- SchemaToType - Edge Cases (3 tests)
- SchemaToType - Fallback Behavior (3 tests)

### Known Limitations

1. **Type widening in complex parsers**: When using `parser.parse()` with many nodes,
   the outputSchema type can get widened from literal `"string"` to generic `string`.
   This is a pre-existing limitation (PRD GAP 6) and is documented in the test.

2. **Requires literal type strings**: The arktype inference only works with literal
   string types. Generic `string` types fall back to `unknown` to prevent infinite
   type recursion.

### Files Modified

- `src/schema/index.ts`: Added arktype import, `ValidArkType`, `ArkTypeSchemaToType`,
  updated `SchemaToType`, added `SchemaToTypeAdvanced` and `ArkTypeSchemaToTypeSafe` helpers
- `src/schema/arktype-integration.test.ts`: New test file with 32 tests
- `src/runtime/eval.test.ts`: Updated 1 test to reflect actual type inference behavior

All 783 tests pass. TypeScript type checking passes. No lint errors (only pre-existing warnings).
